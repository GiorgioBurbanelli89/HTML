<!DOCTYPE html>
<html lang="es">
<head>
    <title>Editor de Dibujo CAD Básico</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta charset="UTF-8">
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #1e1e1e;
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .main-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            width: 100%;
            max-width: 1200px;
        }

        @media (min-width: 1024px) {
            .main-container {
                flex-direction: row;
                align-items: flex-start;
                justify-content: center;
            }
        }

        .canvas-container, #container3D {
            border: 1px solid #444;
            border-radius: 5px;
            position: relative;
            background-color: #2d2d2d;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            width: 95%;
            max-width: 800px;
            height: 500px;
            margin: 0 auto;
        }

        #lienzo {
            display: block;
            background-image: url('https://www.transparenttextures.com/patterns/dark-mosaic.png');
            background-blend-mode: overlay;
            cursor: crosshair;
            width: 100%;
            height: 100%;
        }

        #container3D {
            background-color: #000000;
            cursor: grab;
        }
        #container3D.drawing {
            cursor: crosshair;
        }
        #container3D:active {
            cursor: grabbing;
        }

        .controls-panel {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 5px;
            margin-top: 10px;
            padding: 10px;
            background-color: #2c3e50;
            border-radius: 5px;
            width: 95%;
            max-width: 800px;
        }

        button {
            padding: 5px 10px;
            cursor: pointer;
            background-color: #333;
            color: white;
            border: 1px solid #444;
            border-radius: 3px;
            transition: background-color 0.2s;
        }
        button:hover {
            background-color: #555;
        }
        button:focus {
            outline: 2px solid #3498db;
            outline-offset: 2px;
        }
        button.active {
            background-color: #0066cc;
            color: white;
            border-color: #0056b3;
        }

        .btn-icono {
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #2c3e50;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 8px;
            margin: 3px;
            width: 70px;
            text-align: center;
        }
        .btn-icono.active {
            background-color: #3498db;
        }
        .btn-icono svg {
            margin-bottom: 4px;
            width: 24px;
            height: 24px;
        }
        .btn-icono span {
            font-size: 10px;
            font-weight: bold;
        }

        .zoom-controls {
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            gap: 5px;
            background-color: rgba(0, 0, 0, 0.8);
            padding: 5px;
            border-radius: 5px;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.3);
            z-index: 10;
        }
        .zoom-button {
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: #444;
            border: none;
            color: white;
            cursor: pointer;
            font-size: 18px;
            border-radius: 3px;
        }
        .zoom-button:hover {
            background-color: #666;
        }

        .origin-indicator {
            position: absolute;
            width: 10px;
            height: 10px;
            border: 2px solid yellow;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            background-color: rgba(255, 255, 0, 0.2);
            z-index: 5;
        }
        .origin-indicator::before, .origin-indicator::after {
            content: '';
            position: absolute;
            background-color: yellow;
        }
        .origin-indicator::before {
            width: 1px;
            height: 14px;
            left: 4.5px;
            top: -7px;
        }
        .origin-indicator::after {
            width: 14px;
            height: 1px;
            left: -7px;
            top: 4.5px;
        }
        .origen-label {
            position: absolute;
            font-family: monospace;
            font-size: 10px;
            color: yellow;
            background-color: rgba(0,0,0,0.6);
            padding: 1px 3px;
            border-radius: 2px;
            pointer-events: none;
            z-index: 6;
            transform: translate(10px, -15px);
        }

        #infoBar {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            padding: 5px 10px;
            font-family: monospace;
            font-size: 12px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            display: flex;
            justify-content: space-between;
            box-sizing: border-box;
            border-bottom-left-radius: 5px;
            border-bottom-right-radius: 5px;
            z-index: 10;
        }

        #entradaDimensiones {
            position: absolute;
            bottom: 40px;
            left: 10px;
            padding: 8px;
            border: 1px solid #999;
            border-radius: 4px;
            display: none;
            background-color: rgba(0, 0, 0, 0.9);
            color: white;
            z-index: 11;
        }
        #entradaDimensiones label { margin-right: 5px; }
        #entradaDimensiones input {
            width: 70px;
            background-color: #333;
            color: white;
            border: 1px solid #666;
            padding: 3px;
            border-radius: 2px;
        }
        #entradaDimensiones button { margin-left: 10px; }

        #distanciaVisual, #anguloVisual, #ortoVisual, #anguloInfoElement {
            position: absolute;
            padding: 2px 5px;
            border-radius: 3px;
            color: white;
            font-family: monospace;
            font-size: 12px;
            display: none;
            background-color: rgba(50, 50, 255, 0.8);
            pointer-events: none;
            z-index: 12;
        }
        #anguloVisual { background-color: rgba(0, 0, 0, 0.7); border-radius: 10px; font-size: 10px; }
        #ortoVisual, #anguloInfoElement { background-color: #666; }

        #coordenadasPrecisas {
            position: absolute;
            bottom: 40px;
            left: 200px;
            padding: 5px;
            border-radius: 3px;
            color: white;
            display: flex;
            align-items: center;
            background-color: #555;
            z-index: 11;
        }
        #coordenadasPrecisas span { margin-right: 10px; font-size: 12px;}
        .input-accesible {
            border: 1px solid #666;
            width: 60px;
            padding: 3px;
            border-radius: 3px;
            margin-left: 5px;
        }
        .input-x { color: white; background-color: #007bff; }
        .input-y { color: black; background-color: #eee; }

        #menuSnapObjetos {
            position: absolute;
            padding: 10px;
            border-radius: 5px;
            color: white;
            display: none;
            z-index: 1000;
            box-shadow: 0px 2px 10px rgba(0,0,0,0.3);
            background-color: #2c3e50;
        }
        .snap-option { margin: 3px 0; display: flex; align-items: center;}
        .snap-option input { margin-right: 8px; }
        .snap-option label { font-size: 13px; }

        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.7);
        }
        .modal-content {
            background-color: #2c3e50;
            margin: 10% auto;
            padding: 20px;
            border: 1px solid #888;
            width: 90%;
            max-width: 500px;
            border-radius: 5px;
            color: white;
        }
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #555;
        }
        .modal-header h2, .modal-header h3 { margin: 0; font-size: 1.2em; }
        .close-btn {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: white;
            padding: 0 5px;
        }
        .modal-section { margin-bottom: 15px; }
        .action-buttons { display: flex; justify-content: flex-end; gap: 10px; margin-top: 15px; }
        .action-button { padding: 8px 12px; border: none; border-radius: 3px; cursor: pointer; color: white; }
        .btn-primary { background-color: #3498db; }
        .btn-success { background-color: #2ecc71; }

        .shortcuts-list { margin-bottom: 15px; }
        .shortcut-item { margin-bottom: 8px; display: flex; justify-content: space-between; font-size: 14px; }
        .shortcut-item strong { margin-right: 15px; color: #bdc3c7; }

        .tooltip { position: relative; display: inline-block; }
        .tooltip .tooltiptext {
            visibility: hidden; width: 120px; background-color: #555; color: #fff;
            text-align: center; border-radius: 6px; padding: 5px; position: absolute;
            z-index: 1; bottom: 125%; left: 50%; margin-left: -60px; opacity: 0; transition: opacity 0.3s;
        }
        .tooltip:hover .tooltiptext { visibility: visible; opacity: 1; }

        .sr-only {
            position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px;
            overflow: hidden; clip: rect(0, 0, 0, 0); white-space: nowrap; border-width: 0;
        }

        .mensaje-temporal {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            z-index: 2000;
            font-family: Arial, sans-serif;
            font-size: 14px;
            opacity: 1;
            transition: opacity 0.5s ease-out;
        }
        .mensaje-temporal.fade-out {
            opacity: 0;
        }
    </style>
</head>
<body>
    <h3>Editor de Dibujo CAD Básico</h3>

    <div class="main-container">
        <div style="display: flex; flex-direction: column; align-items: center; width: 100%; max-width: 850px;">
            <div class="canvas-container">
                <canvas width="800" height="500" tabindex="0" id="lienzo" aria-label="Área de dibujo CAD 2D"></canvas>
                <div class="zoom-controls" role="group" aria-label="Controles de zoom">
                    <button class="zoom-button" id="zoomIn" aria-label="Aumentar zoom">+</button>
                    <button class="zoom-button" id="zoomOut" aria-label="Reducir zoom">-</button>
                    <button class="zoom-button" id="zoomFit" aria-label="Ajustar zoom a ventana">□</button>
                </div>
                <div id="originIndicator2D" class="origin-indicator" aria-hidden="true"></div>
                <div id="originLabel2D" class="origen-label" aria-hidden="true">0,0</div>
                <div id="infoBar">
                    <div id="coordCanvas">X: 0, Y: 0</div>
                    <div id="snapInfo"></div>
                    <div id="lineInfo">Longitud: 0 | Ángulo: 0°</div>
                </div>
                <div id="entradaDimensiones">
                    <div class="form-group">
                        <label for="inputDistancia">Distancia:</label>
                        <input id="inputDistancia" type="number" step="0.1" aria-label="Introduzca la distancia">
                    </div>
                    <button id="btnAplicarDimensiones">Aplicar</button>
                </div>
                <div id="coordenadasPrecisas">
                    <span>Punto:</span>
                    <div class="form-group">
                        <label for="inputX" class="sr-only">Coordenada X</label>
                        <input id="inputX" class="input-accesible input-x" type="number" step="0.1" value="0" aria-label="Coordenada X">
                    </div>
                    <div class="form-group">
                        <label for="inputY" class="sr-only">Coordenada Y</label>
                        <input id="inputY" class="input-accesible input-y" type="number" step="0.1" value="0" aria-label="Coordenada Y">
                    </div>
                </div>
                <div id="distanciaVisual" aria-hidden="true"></div>
                <div id="anguloVisual" aria-hidden="true"></div>
                <div id="ortoVisual" aria-hidden="true"></div>
                <div id="anguloInfoElement" aria-hidden="true"></div>
            </div>

            <div class="controls-panel">
                <button title="Línea (L)" class="btn-icono active" id="btnLinea" aria-label="Herramienta Línea">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><line x1="5" y1="19" x2="19" y2="5"></line><circle cx="5" cy="19" r="2" fill="#3498db"></circle><circle cx="19" cy="5" r="2" fill="#3498db"></circle></svg>
                    <span>Línea</span>
                </button>
                <button title="Polilínea (P)" class="btn-icono" id="btnPolilinea" aria-label="Herramienta Polilínea">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><polyline points="4 20 10 10 16 16 20 14"></polyline><circle cx="4" cy="20" r="2" fill="#3498db"></circle><circle cx="10" cy="10" r="2" fill="#3498db"></circle><circle cx="20" cy="14" r="2" fill="#3498db"></circle></svg>
                    <span>Polilínea</span>
                </button>
                <button title="Rectángulo (R)" class="btn-icono" id="btnRectangulo" aria-label="Herramienta Rectángulo">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><rect x="4" y="4" width="16" height="16" rx="1"></rect><circle cx="4" cy="4" r="2" fill="#3498db"></circle><circle cx="20" cy="20" r="2" fill="#3498db"></circle></svg>
                    <span>Rectángulo</span>
                </button>
                <button title="Círculo (C)" class="btn-icono" id="btnCirculo" aria-label="Herramienta Círculo">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><circle cx="12" cy="12" r="8"></circle><circle cx="12" cy="12" r="2" fill="#3498db"></circle><line x1="12" y1="12" x2="20" y2="12" stroke="#3498db" stroke-width="1"></line></svg>
                    <span>Círculo</span>
                </button>
                <button title="Elipse (E)" class="btn-icono" id="btnElipse" aria-label="Herramienta Elipse">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><ellipse cx="12" cy="12" rx="8" ry="5"></ellipse><circle cx="12" cy="12" r="2" fill="#3498db"></circle></svg>
                    <span>Elipse</span>
                </button>
                <!-- Desactivados temporalmente hasta implementar los modos -->
                <!--
                <button title="Arco (A)" class="btn-icono" id="btnArco" aria-label="Herramienta Arco">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true"><path d="M 4 20 A 10 10 0 0 1 20 20"></path><circle cx="4" cy="20" r="2" fill="#3498db"></circle><circle cx="20" cy="20" r="2" fill="#3498db"></circle></svg>
                    <span>Arco</span>
                </button>
                <button title="Mano Alzada (F)" class="btn-icono" id="btnMano" aria-label="Herramienta Mano Alzada">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21.174 6.812a1 1 0 0 0-3.986-3.987L6.846 17.175l-2.13 7.173 7.173-2.13z"/><path d="M19.263 7.737a1 1 0 1 0-1.414-1.414L7.737 19.263a1 1 0 1 0 1.414 1.414z"/></svg>
                    <span>Mano</span>
                </button>
                -->

                <button id="btnDimension" aria-label="Activar entrada de dimensiones">Dimensión</button>
                <button id="btnRestriccion" aria-label="Activar restricción de ángulo 90 grados (F8)">Orto (OFF)</button>
                <div class="tooltip">
                    <button id="btnSnap" aria-label="Activar snap a objetos (F3)" aria-haspopup="true" aria-expanded="false">Snap (ON)</button>
                    <div id="menuSnapObjetos" role="menu" aria-label="Opciones de snap">
                        <div class="snap-option"><input id="snapEndpoint" type="checkbox" role="menuitemcheckbox" aria-checked="true" checked><label for="snapEndpoint">Punto final</label></div>
                        <div class="snap-option"><input id="snapMidpoint" type="checkbox" role="menuitemcheckbox" aria-checked="true" checked><label for="snapMidpoint">Punto medio</label></div>
                        <div class="snap-option"><input id="snapCenter" type="checkbox" role="menuitemcheckbox" aria-checked="true" checked><label for="snapCenter">Centro</label></div>
                        <div class="snap-option"><input id="snapIntersection" type="checkbox" role="menuitemcheckbox" aria-checked="false"><label for="snapIntersection">Intersección</label></div>
                        <!-- Ajustados para coincidir con tiposSnap -->
                    </div>
                </div>
                <button id="btnRejilla" aria-label="Activar rejilla visual (F7)">Rejilla (ON)</button>
                <button id="btnSnapGrid" aria-label="Activar snap a rejilla (F9)">Snap Rejilla (OFF)</button>

                <button id="btnDeshacer" aria-label="Deshacer última acción (Ctrl+Z)">Deshacer</button>
                <!-- Añadido btnRehacer para soportar rehacer -->
                <button id="btnRehacer" aria-label="Rehacer última acción (Ctrl+Shift+Z)">Rehacer</button>
                <button id="btnLimpiar" aria-label="Limpiar todo el lienzo">Limpiar</button>
                <button id="btnGuardarSVG" aria-label="Guardar dibujo como SVG">Guardar SVG</button>
                <button id="btnImportarSVG" aria-label="Importar archivo SVG">Importar SVG</button>
                <button id="btnAtajos" aria-label="Mostrar atajos de teclado">Atajos</button>
                <button id="btnToggle3D">Activar 3D</button>
                <button id="btnReiniciarVista3D">Resetear 3D</button>
                <button id="btnCentrarVistas">Centrar Vistas</button>
            </div>
        </div>

        <div style="display: flex; flex-direction: column; align-items: center; width: 100%; max-width: 850px;">
    <div id="container3D" style="display: none; width: 800px; height: 600px;" aria-label="Área de visualización 3D"></div>
</div>
    </div>

    <div class="form-group" style="margin-top: 10px; width: 95%; max-width: 800px; display: none;">
        <label for="svgOutput" class="sr-only">Código SVG generado</label>
        <textarea id="svgOutput" style="width: 100%; height: 100px; font-family: monospace; background-color: #333; color: white; border: 1px solid #555;" aria-label="Código SVG generado" readonly></textarea>
    </div>

    <div id="modalAtajos" class="modal" aria-labelledby="tituloAtajos" aria-hidden="true">
        <div class="modal-content">
            <div class="modal-header">
                <h3 id="tituloAtajos">Atajos de Teclado</h3>
                <button id="cerrarModalAtajos" class="close-btn" aria-label="Cerrar ventana de atajos">×</button>
            </div>
            <div class="shortcuts-list">
                <div class="shortcut-item"><strong>ESC</strong><span>Cancelar operación actual / Cerrar menú</span></div>
                <div class="shortcut-item"><strong>L</strong><span>Herramienta Línea</span></div>
                <div class="shortcut-item"><strong>P</strong><span>Herramienta Polilínea</span></div>
                <div class="shortcut-item"><strong>R</strong><span>Herramienta Rectángulo</span></div>
                <div class="shortcut-item"><strong>C</strong><span>Herramienta Círculo</span></div>
                <div class="shortcut-item"><strong>E</strong><span>Herramienta Elipse</span></div>
                <!-- Desactivados hasta implementar los modos -->
                <!--
                <div class="shortcut-item"><strong>A</strong><span>Herramienta Arco</span></div>
                <div class="shortcut-item"><strong>F</strong><span>Herramienta Mano Alzada</span></div>
                -->
                <div class="shortcut-item"><strong>F3</strong><span>Activar/Desactivar Snap a Objetos</span></div>
                <div class="shortcut-item"><strong>F7</strong><span>Activar/Desactivar Rejilla 2D</span></div>
                <div class="shortcut-item"><strong>F8</strong><span>Activar/Desactivar Modo Ortogonal</span></div>
                <div class="shortcut-item"><strong>F9</strong><span>Activar/Desactivar Snap a Rejilla</span></div>
                <div class="shortcut-item"><strong>Ctrl+Z</strong><span>Deshacer</span></div>
                <div class="shortcut-item"><strong>Ctrl+Shift+Z</strong><span>Rehacer</span></div>
                <div class="shortcut-item"><strong>Rueda Ratón</strong><span>Zoom 2D</span></div>
                <div class="shortcut-item"><strong>Botón Medio Ratón</strong><span>Panorámica 2D</span></div>
            </div>
            <div class="action-buttons">
                <button id="btnCerrarAtajos" class="action-button btn-primary">Cerrar</button>
            </div>
        </div>
    </div>

    <div id="modalImportarSVG" class="modal" aria-labelledby="tituloImportarSVG" aria-hidden="true">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="tituloImportarSVG">Importar SVG</h2>
                <button id="cerrarModalImportarSVG" class="close-btn" aria-label="Cerrar ventana de importación">×</button>
            </div>
            <div class="modal-section">
                <h3>Cargar archivo SVG</h3>
                <div class="form-group">
                    <label for="inputArchivoSVG" class="sr-only">Seleccionar archivo SVG</label>
                    <input type="file" id="inputArchivoSVG" accept=".svg" aria-label="Seleccionar archivo SVG para importar" style="color: white;">
                </div>
            </div>
            <div class="modal-section">
                <h3>Pegar código SVG</h3>
                <div class="form-group">
                    <label for="textareaSVG" class="sr-only">Código SVG</label>
                    <textarea id="textareaSVG" rows="8" style="width: 100%; resize: vertical; background-color: #333; color: white; border: 1px solid #555;" aria-label="Pegar código SVG aquí"></textarea>
                </div>
            </div>
            <div class="action-buttons">
                <button id="btnPegarSVG" class="action-button btn-primary">Importar desde Texto</button>
                <button id="btnCargarSVG" class="action-button btn-success">Importar desde Archivo</button>
            </div>
        </div>
    </div>

    <!-- Scripts al final del body para asegurar que el DOM y Three.js estén cargados -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.134.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.134.0/examples/js/controls/OrbitControls.js"></script>
   </body>
</html>
    <script>
    "use strict";

    // =========================================================================
    // Módulo de Configuración
    // =========================================================================
    const Config = {
        MIN_ZOOM: 0.1,
        MAX_ZOOM: 10,
        ZOOM_SPEED: 0.1,
        MAX_HISTORIAL: 50, // Aumentado historial
        TAMANO_REJILLA_2D: 20,
        COLOR_FONDO_2D: '#2d2d2d',
        COLOR_REJILLA_2D: '#444444',
        COLOR_EJES_2D: '#cccccc',
        COLOR_ORIGEN_2D: 'yellow',
        COLOR_LINEA_DEFAULT: '#ffffff',
        COLOR_SNAP: '#00ffff', // Cyan for snap points
        SNAP_RADIUS: 10, // Pixels for snap detection
        TAMANO_REJILLA_3D: 800, // Size of the 3D grid helper
        DIVISIONES_REJILLA_3D: 40, // Corresponds to TAMANO_REJILLA_2D (800 / 20)
        COLOR_CENTRO_3D: 0x888888,
        COLOR_REJILLA_3D: 0x444444,
        COLOR_LINEA_3D: 0xffffff,
        COLOR_LINEA_TEMP_3D: 0xffaa00, // Orange for temporary 3D line
    };

    // =========================================================================
    // Variables Globales del Estado de la Aplicación
    // =========================================================================
    // --- Canvas 2D ---
    let canvas, ctx;
    let zoomLevel = 1;
    let panX = 0, panY = 0; // Renombrado desde lastTranslateX/Y
    let isPanning = false, startPanX = 0, startPanY = 0;
    let formas = []; // Almacena todas las formas dibujadas en 2D
    let snapPuntos = []; // Puntos de snap calculados
    let historialEstados = []; // Para deshacer/rehacer
    let posicionHistorial = -1;
    let puntoInicial = null; // Punto de inicio para la operación de dibujo actual
    let modoActual = "linea"; // Herramienta seleccionada
    let rejillaActiva = true; // Estado de la rejilla 2D
    let snapActivo = false; // Estado del snap a objetos
    let snapToGridActivo = false; // Estado del snap a la rejilla 2D
    let restriccionAngulo = false; // Modo ortogonal
    let dimensionManualActiva = false; // Entrada manual de dimensiones
    let anguloActual = 0; // Ángulo de la línea/operación actual
    let dibujando = false; // Para modo mano alzada
    let xAnterior, yAnterior; // Para modo mano alzada
    let puntosPolilinea = [];
    let dibujarPolilineaEnProgreso = false;
    let puntosArco = [];
    let dibujarArcoEnProgreso = false;
    let ultimoClickTimestamp = 0; // Para detectar doble clic

    // --- Canvas 3D ---
    let container3D; // Div contenedor para la escena 3D
    let scene, camera, renderer, controls, gridHelper3D, plane3D; // Elementos de Three.js
    let escena3DInitializada = false;
    let lineas3D_derivadas = []; // Líneas en 3D generadas a partir del dibujo 2D
    let lineas3D_directas = []; // Líneas dibujadas directamente en 3D
    let isDrawing3D = false; // Bandera para indicar si se está dibujando en 3D
    let startPoint3D = null; // Punto de inicio para línea 3D
    let tempLine3D = null; // Línea temporal mientras se dibuja en 3D
    const raycaster = new THREE.Raycaster();
    const mouseNDC = new THREE.Vector2(); // Coordenadas Normalizadas del Dispositivo (-1 a +1)

    // --- Elementos UI ---
    let coordsElement, snapInfoElement, lineInfoElement;
    let anguloVisualElement, distanciaVisualElement, ortoVisualElement, anguloInfoElement;
    let entradaDimensionesElement, inputDistanciaElement;
    let inputXElement, inputYElement;
    let originIndicator2D, originLabel2D;
    let btnToggle3D;

    // --- Configuración Snap ---
    const tiposSnap = {
        puntoFinal: true,
        puntoMedio: true,
        centro: true,
        cuadrante: true,
        interseccion: false,
        cercano: false,
        // Añadir más si se implementan:
        // centroGeometrico: false,
        // punto: true,
        // extension: false,
        // insercion: false,
        // perpendicular: false,
        // tangente: false,
        // interseccionFicticia: false,
        // paralelo: false
    };

    // =========================================================================
    // Módulo de Utilidades Generales
    // =========================================================================
    const Utilidades = {
        mostrarMensajeTemporalEstado(mensaje, duracion = 2000) {
            // Eliminar mensaje anterior si existe
            const mensajeExistente = document.querySelector(".mensaje-temporal");
            if (mensajeExistente) {
                mensajeExistente.remove();
            }

            // Crear nuevo elemento de mensaje
            const mensajeElement = document.createElement("div");
            mensajeElement.className = "mensaje-temporal";
            mensajeElement.textContent = mensaje;
            mensajeElement.setAttribute('role', 'status');
            mensajeElement.setAttribute('aria-live', 'polite');
            document.body.appendChild(mensajeElement);

            // Desvanecer y eliminar después de la duración
            setTimeout(() => {
                mensajeElement.classList.add('fade-out');
                setTimeout(() => mensajeElement.remove(), 500); // Esperar a que termine la transición
            }, duracion);
        },

calcularDistancia(x1, y1, x2, y2) {
    const dx = x2 - x1;
    const dy = y2 - y1;
    return Math.sqrt(dx * dx + dy * dy);
},

        calcularAngulo(x1, y1, x2, y2) {
            const anguloRad = Math.atan2(y2 - y1, x2 - x1);
            let anguloDeg = anguloRad * 180 / Math.PI;
            // Normalizar a 0-360 grados
            //if (anguloDeg < 0) anguloDeg += 360;
            return anguloDeg;
        },

restringirAngulo(x1, y1, x2, y2) {
    if (!restriccionAngulo) return { x: x2, y: y2 };

    const anguloRad = Math.atan2(y2 - y1, x2 - x1);
    const angulosOrto = [0, Math.PI / 2, Math.PI, -Math.PI / 2];
    let anguloMasCercano = angulosOrto[0];
    let diferenciaMinima = Math.abs(anguloRad - anguloMasCercano);

    for (let i = 1; i < angulosOrto.length; i++) {
        let diferencia = Math.abs(anguloRad - angulosOrto[i]);
        diferencia = Math.min(diferencia, 2 * Math.PI - diferencia);
        if (diferencia < diferenciaMinima) {
            diferenciaMinima = diferencia;
            anguloMasCercano = angulosOrto[i];
        }
    }

    if (anguloMasCercano < 0) {
        anguloMasCercano += 2 * Math.PI;
    }

    const distancia = this.calcularDistancia(x1, y1, x2, y2);
    const newX = x1 + Math.cos(anguloMasCercano) * distancia;
    const newY = y1 + Math.sin(anguloMasCercano) * distancia;

    return { x: newX, y: newY };
},

        ajustarARejilla(x, y) {
            if (!snapToGridActivo) return { x: x, y: y };
            const gridX = Math.round(x / Config.TAMANO_REJILLA_2D) * Config.TAMANO_REJILLA_2D;
            const gridY = Math.round(y / Config.TAMANO_REJILLA_2D) * Config.TAMANO_REJILLA_2D;
            return { x: gridX, y: gridY };
        },

        registrarEventos(elementId, eventos) {
            const elemento = document.getElementById(elementId);
            if (!elemento) {
                console.warn(`Elemento con ID '${elementId}' no encontrado para registrar eventos.`);
                return;
            }
            Object.entries(eventos).forEach(([evento, manejador]) => {
                elemento.addEventListener(evento, manejador);
            });
        },

        formatearNumero(num, decimales = 2) {
            return Number(num.toFixed(decimales));
        },

        // Convierte coordenadas de pantalla 2D a coordenadas del canvas 2D (considerando pan y zoom)
screenToCanvas(screenX, screenY) {
    const rect = canvas.getBoundingClientRect();
    const canvasX = (screenX - rect.left) / zoomLevel - panX;
    const canvasY = (screenY - rect.top) / zoomLevel - panY;
    console.log('screenToCanvas - Screen:', screenX, screenY, 'Canvas:', canvasX, canvasY, 'Zoom:', zoomLevel, 'Pan:', panX, panY, 'Rect:', rect.left, rect.top);
    return { x: canvasX, y: canvasY };
},

// Convierte coordenadas del canvas 2D a coordenadas de pantalla 2D
canvasToScreen(canvasX, canvasY) {
    const rect = canvas.getBoundingClientRect();
    const screenX = (canvasX + panX) * zoomLevel + rect.left;
    const screenY = (canvasY + panY) * zoomLevel + rect.top;
    console.log('canvasToScreen - Canvas:', canvasX, canvasY, 'Screen:', screenX, screenY, 'Zoom:', zoomLevel, 'Pan:', panX, panY, 'Rect:', rect.left, rect.top);
    return { x: screenX, y: screenY };
},

        // Convierte coordenadas de pantalla (del contenedor 3D) a coordenadas del mundo 3D en el plano Z=0
        screenToWorld3D(screenX, screenY) {
            if (!camera || !container3D) return null;

            const rect = container3D.getBoundingClientRect();
            // Normalizar coordenadas del mouse a NDC (-1 a +1)
            mouseNDC.x = ((screenX - rect.left) / rect.width) * 2 - 1;
            mouseNDC.y = -((screenY - rect.top) / rect.height) * 2 + 1;

            // Lanzar rayo
            raycaster.setFromCamera(mouseNDC, camera);

            // Intersección con el plano Z=0 (representado por el GridHelper o un plano invisible)
            // Usamos el gridHelper directamente si está disponible y visible
            // O un plano matemático si no
            let targetPlane = plane3D; // Usar el plano invisible
            // if (gridHelper3D && gridHelper3D.parent) {
            //     targetPlane = gridHelper3D; // Intentar con la rejilla si está en la escena
            // }

            const intersects = raycaster.intersectObject(targetPlane);

            if (intersects.length > 0) {
                return intersects[0].point; // Devuelve el THREE.Vector3 de la intersección
            }

            return null; // No hubo intersección
        },

        // Genera un ID único simple (para formas, etc.)
        generarIdUnico() {
            return Date.now().toString(36) + Math.random().toString(36).substring(2);
        }
    };

// =========================================================================
// Módulo de Dibujo (Lógica de creación y manipulación de formas)
// =========================================================================
const Dibujo = {
    actualizarTodasLasLineas3D() {
        if (!escena3DInitializada) return;
        formas.forEach(forma => {
            if (forma.tipo === "linea") {
                Escena3D.actualizarLinea3D(forma);
            }
        });
    },

    actualizarVista3D(nuevaForma) {
        if (!escena3DInitializada) return;
        if (nuevaForma.tipo === "linea") {
            Escena3D.actualizarLinea3D(nuevaForma);
        }
        // Puedes agregar más lógica para otros tipos de formas (rectángulo, círculo, etc.) si es necesario
    },

    actualizarSnapPuntos() {
        snapPuntos = [];
        // Añadir origen
        snapPuntos.push({ x: 0, y: 0, tipo: "origen", formaId: 'origen' });

        formas.forEach(forma => {
            switch (forma.tipo) {
                case "linea":
                    if (tiposSnap.puntoFinal) {
                        snapPuntos.push({ x: forma.x1, y: forma.y1, tipo: "punto final", formaId: forma.id });
                        snapPuntos.push({ x: forma.x2, y: forma.y2, tipo: "punto final", formaId: forma.id });
                    }
                    if (tiposSnap.puntoMedio) {
                        snapPuntos.push({ x: (forma.x1 + forma.x2) / 2, y: (forma.y1 + forma.y2) / 2, tipo: "punto medio", formaId: forma.id });
                    }
                    break;
                case "rectangulo":
                    const x1 = forma.x, y1 = forma.y;
                    const x2 = forma.x + forma.ancho, y2 = forma.y + forma.alto;
                    if (tiposSnap.puntoFinal) {
                        snapPuntos.push({ x: x1, y: y1, tipo: "punto final", formaId: forma.id }); // Top-left
                        snapPuntos.push({ x: x2, y: y1, tipo: "punto final", formaId: forma.id }); // Top-right
                        snapPuntos.push({ x: x1, y: y2, tipo: "punto final", formaId: forma.id }); // Bottom-left
                        snapPuntos.push({ x: x2, y: y2, tipo: "punto final", formaId: forma.id }); // Bottom-right
                    }
                    if (tiposSnap.puntoMedio) {
                        snapPuntos.push({ x: (x1 + x2) / 2, y: y1, tipo: "punto medio", formaId: forma.id }); // Mid-top
                        snapPuntos.push({ x: x2, y: (y1 + y2) / 2, tipo: "punto medio", formaId: forma.id }); // Mid-right
                        snapPuntos.push({ x: (x1 + x2) / 2, y: y2, tipo: "punto medio", formaId: forma.id }); // Mid-bottom
                        snapPuntos.push({ x: x1, y: (y1 + y2) / 2, tipo: "punto medio", formaId: forma.id }); // Mid-left
                    }
                    // if (tiposSnap.centroGeometrico) { ... }
                    break;
                case "circulo":
                    if (tiposSnap.centro) {
                        snapPuntos.push({ x: forma.x, y: forma.y, tipo: "centro", formaId: forma.id });
                    }
                    if (tiposSnap.cuadrante) {
                        snapPuntos.push({ x: forma.x + forma.radio, y: forma.y, tipo: "cuadrante", formaId: forma.id }); // 0 deg
                        snapPuntos.push({ x: forma.x, y: forma.y + forma.radio, tipo: "cuadrante", formaId: forma.id }); // 90 deg
                        snapPuntos.push({ x: forma.x - forma.radio, y: forma.y, tipo: "cuadrante", formaId: forma.id }); // 180 deg
                        snapPuntos.push({ x: forma.x, y: forma.y - forma.radio, tipo: "cuadrante", formaId: forma.id }); // 270 deg
                    }
                    break;
                case "elipse":
                    if (tiposSnap.centro) {
                        snapPuntos.push({ x: forma.x, y: forma.y, tipo: "centro", formaId: forma.id });
                    }
                    if (tiposSnap.cuadrante) {
                        snapPuntos.push({ x: forma.x + forma.radiusX, y: forma.y, tipo: "cuadrante", formaId: forma.id });
                        snapPuntos.push({ x: forma.x - forma.radiusX, y: forma.y, tipo: "cuadrante", formaId: forma.id });
                        snapPuntos.push({ x: forma.x, y: forma.y + forma.radiusY, tipo: "cuadrante", formaId: forma.id });
                        snapPuntos.push({ x: forma.x, y: forma.y - forma.radiusY, tipo: "cuadrante", formaId: forma.id });
                    }
                    break;
                case "polilinea":
                    if (forma.puntos && forma.puntos.length > 0) {
                        if (tiposSnap.puntoFinal) {
                            forma.puntos.forEach(p => snapPuntos.push({ x: p.x, y: p.y, tipo: "punto final", formaId: forma.id }));
                        }
                        if (tiposSnap.puntoMedio && forma.puntos.length > 1) {
                            for (let i = 0; i < forma.puntos.length - 1; i++) {
                                snapPuntos.push({
                                    x: (forma.puntos[i].x + forma.puntos[i+1].x) / 2,
                                    y: (forma.puntos[i].y + forma.puntos[i+1].y) / 2,
                                    tipo: "punto medio", formaId: forma.id
                                });
                            }
                        }
                    }
                    break;
                case "arco":
                    if (tiposSnap.puntoFinal) {
                        snapPuntos.push({ x: forma.x1, y: forma.y1, tipo: "punto final", formaId: forma.id });
                        snapPuntos.push({ x: forma.x2, y: forma.y2, tipo: "punto final", formaId: forma.id });
                    }
                    // Snap a punto medio del arco es más complejo, omitido por ahora
                    break;
            }
        });
    },

    iniciarDibujo(x, y, dobleClic) {
        // Si estamos en modo 3D, no hacemos nada aquí
        if (isDrawing3D) return;

        // Ajustar las coordenadas al snap si está activo
        const adjustedPoint = Utilidades.aplicarSnap(x, y);
        x = adjustedPoint.x;
        y = adjustedPoint.y;

        // Iniciar el dibujo según el modo actual
        if (modoActual === "linea" || modoActual === "rectangulo" || modoActual === "circulo" || modoActual === "elipse") {
            if (!dibujando) {
                puntoInicial = { x, y };
                dibujando = true;
                xAnterior = x;
                yAnterior = y;
                Utilidades.mostrarMensajeTemporalEstado("Punto inicial seleccionado. Haz clic para finalizar.");
            }
        } else if (modoActual === "polilinea") {
            if (!dibujando) {
                puntoInicial = { x, y };
                dibujando = true;
                xAnterior = x;
                yAnterior = y;
                Utilidades.mostrarMensajeTemporalEstado("Polilínea iniciada. Haz clic para añadir puntos, doble clic para finalizar.");
            } else if (dobleClic) {
                // Doble clic finaliza la polilínea
                puntoInicial = null;
                dibujando = false;
                Utilidades.mostrarMensajeTemporalEstado("Polilínea finalizada.");
            }
        }

        Canvas2D.dibujar();
    },

    finalizarDibujoEn(x, y) {
        if (!puntoInicial) return;

        const puntoFinalOriginal = { x, y };
        const puntoFinal = restriccionAngulo
            ? Utilidades.restringirAngulo(puntoInicial.x, puntoInicial.y, x, y)
            : puntoFinalOriginal;

        let nuevaForma = null;
        ctx.strokeStyle = Config.COLOR_LINEA_DEFAULT;
        ctx.lineWidth = 1.5 / zoomLevel;

        console.log("Finalizar dibujo - Inicial:", puntoInicial, "Final:", puntoFinal);

        switch (modoActual) {
            case "linea":
                nuevaForma = {
                    id: Utilidades.generarIdUnico(),
                    tipo: "linea",
                    x1: puntoInicial.x,
                    y1: puntoInicial.y,
                    x2: puntoFinal.x,
                    y2: puntoFinal.y,
                    color: Config.COLOR_LINEA_DEFAULT,
                };
                Canvas2D.dibujarLinea(puntoInicial.x, puntoInicial.y, puntoFinal.x, puntoFinal.y);
                Utilidades.mostrarMensajeTemporalEstado("Línea creada");
                break;

            case "polilinea":
                nuevaForma = {
                    id: Utilidades.generarIdUnico(),
                    tipo: "linea", // Cada segmento es una línea
                    x1: puntoInicial.x,
                    y1: puntoInicial.y,
                    x2: puntoFinal.x,
                    y2: puntoFinal.y,
                    color: Config.COLOR_LINEA_DEFAULT,
                };
                Canvas2D.dibujarLinea(puntoInicial.x, puntoInicial.y, puntoFinal.x, puntoFinal.y);
                Utilidades.mostrarMensajeTemporalEstado("Segmento de polilínea creado");
                puntoInicial = { x: puntoFinal.x, y: puntoFinal.y }; // Continuar desde el punto final
                break;

            case "rectangulo":
                const ancho = puntoFinal.x - puntoInicial.x;
                const alto = puntoFinal.y - puntoInicial.y;
                nuevaForma = {
                    id: Utilidades.generarIdUnico(),
                    tipo: "rectangulo",
                    x: puntoInicial.x,
                    y: puntoInicial.y,
                    ancho: ancho,
                    alto: alto,
                    color: Config.COLOR_LINEA_DEFAULT,
                };
                Canvas2D.dibujarRectangulo(puntoInicial.x, puntoInicial.y, ancho, alto);
                Utilidades.mostrarMensajeTemporalEstado("Rectángulo creado");
                break;

            case "circulo":
                const radio = Utilidades.calcularDistancia(puntoInicial.x, puntoInicial.y, puntoFinal.x, puntoFinal.y);
                nuevaForma = {
                    id: Utilidades.generarIdUnico(),
                    tipo: "circulo",
                    x: puntoInicial.x,
                    y: puntoInicial.y,
                    radio: radio,
                    color: Config.COLOR_LINEA_DEFAULT,
                };
                Canvas2D.dibujarCirculo(puntoInicial.x, puntoInicial.y, radio);
                Utilidades.mostrarMensajeTemporalEstado("Círculo creado");
                break;

            case "elipse":
                const radiusX = Math.abs(puntoFinal.x - puntoInicial.x) / 2;
                const radiusY = Math.abs(puntoFinal.y - puntoInicial.y) / 2;
                const centroX = puntoInicial.x + (puntoFinal.x - puntoInicial.x) / 2;
                const centroY = puntoInicial.y + (puntoFinal.y - puntoInicial.y) / 2;
                nuevaForma = {
                    id: Utilidades.generarIdUnico(),
                    tipo: "elipse",
                    x: centroX,
                    y: centroY,
                    radiusX: radiusX,
                    radiusY: radiusY,
                    color: Config.COLOR_LINEA_DEFAULT,
                };
                Canvas2D.dibujarElipse(centroX, centroY, radiusX, radiusY);
                Utilidades.mostrarMensajeTemporalEstado("Elipse creada");
                break;
        }

        if (nuevaForma) {
            formas.push(nuevaForma);
            this.actualizarVista3D(nuevaForma);
            this.actualizarSnapPuntos();
            Canvas2D.guardarEstado();
        }

        if (modoActual !== "polilinea") {
            puntoInicial = null;
            Canvas2D.ocultarIndicadoresVisuales();
            dibujando = false;
        }

        Canvas2D.dibujar();
    },
};// =========================================================================
// Módulo de Dibujo (Lógica de creación y manipulación de formas)
// =========================================================================
const Dibujo = {
    actualizarTodasLasLineas3D() {
        if (!escena3DInitializada) return;
        formas.forEach(forma => {
            if (forma.tipo === "linea") {
                Escena3D.actualizarLinea3D(forma);
            }
        });
    },
};

    actualizarVista3D(nuevaForma) {
        if (!escena3DInitializada) return;
        if (nuevaForma.tipo === "linea") {
            Escena3D.actualizarLinea3D(nuevaForma);
        }
        // Puedes agregar más lógica para otros tipos de formas (rectángulo, círculo, etc.) si es necesario
    },

    actualizarSnapPuntos() {
        snapPuntos = [];
        // Añadir origen
        snapPuntos.push({ x: 0, y: 0, tipo: "origen", formaId: 'origen' });

        formas.forEach(forma => {
            switch (forma.tipo) {
                case "linea":
                    if (tiposSnap.puntoFinal) {
                        snapPuntos.push({ x: forma.x1, y: forma.y1, tipo: "punto final", formaId: forma.id });
                        snapPuntos.push({ x: forma.x2, y: forma.y2, tipo: "punto final", formaId: forma.id });
                    }
                    if (tiposSnap.puntoMedio) {
                        snapPuntos.push({ x: (forma.x1 + forma.x2) / 2, y: (forma.y1 + forma.y2) / 2, tipo: "punto medio", formaId: forma.id });
                    }
                    break;
                case "rectangulo":
                    const x1 = forma.x, y1 = forma.y;
                    const x2 = forma.x + forma.ancho, y2 = forma.y + forma.alto;
                    if (tiposSnap.puntoFinal) {
                        snapPuntos.push({ x: x1, y: y1, tipo: "punto final", formaId: forma.id }); // Top-left
                        snapPuntos.push({ x: x2, y: y1, tipo: "punto final", formaId: forma.id }); // Top-right
                        snapPuntos.push({ x: x1, y: y2, tipo: "punto final", formaId: forma.id }); // Bottom-left
                        snapPuntos.push({ x: x2, y: y2, tipo: "punto final", formaId: forma.id }); // Bottom-right
                    }
                    if (tiposSnap.puntoMedio) {
                        snapPuntos.push({ x: (x1 + x2) / 2, y: y1, tipo: "punto medio", formaId: forma.id }); // Mid-top
                        snapPuntos.push({ x: x2, y: (y1 + y2) / 2, tipo: "punto medio", formaId: forma.id }); // Mid-right
                        snapPuntos.push({ x: (x1 + x2) / 2, y: y2, tipo: "punto medio", formaId: forma.id }); // Mid-bottom
                        snapPuntos.push({ x: x1, y: (y1 + y2) / 2, tipo: "punto medio", formaId: forma.id }); // Mid-left
                    }
                    // if (tiposSnap.centroGeometrico) { ... }
                    break;
                case "circulo":
                    if (tiposSnap.centro) {
                        snapPuntos.push({ x: forma.x, y: forma.y, tipo: "centro", formaId: forma.id });
                    }
                    if (tiposSnap.cuadrante) {
                        snapPuntos.push({ x: forma.x + forma.radio, y: forma.y, tipo: "cuadrante", formaId: forma.id }); // 0 deg
                        snapPuntos.push({ x: forma.x, y: forma.y + forma.radio, tipo: "cuadrante", formaId: forma.id }); // 90 deg
                        snapPuntos.push({ x: forma.x - forma.radio, y: forma.y, tipo: "cuadrante", formaId: forma.id }); // 180 deg
                        snapPuntos.push({ x: forma.x, y: forma.y - forma.radio, tipo: "cuadrante", formaId: forma.id }); // 270 deg
                    }
                    break;
                case "elipse":
                    if (tiposSnap.centro) {
                        snapPuntos.push({ x: forma.x, y: forma.y, tipo: "centro", formaId: forma.id });
                    }
                    if (tiposSnap.cuadrante) {
                        snapPuntos.push({ x: forma.x + forma.radiusX, y: forma.y, tipo: "cuadrante", formaId: forma.id });
                        snapPuntos.push({ x: forma.x - forma.radiusX, y: forma.y, tipo: "cuadrante", formaId: forma.id });
                        snapPuntos.push({ x: forma.x, y: forma.y + forma.radiusY, tipo: "cuadrante", formaId: forma.id });
                        snapPuntos.push({ x: forma.x, y: forma.y - forma.radiusY, tipo: "cuadrante", formaId: forma.id });
                    }
                    break;
                case "polilinea":
                    if (forma.puntos && forma.puntos.length > 0) {
                        if (tiposSnap.puntoFinal) {
                            forma.puntos.forEach(p => snapPuntos.push({ x: p.x, y: p.y, tipo: "punto final", formaId: forma.id }));
                        }
                        if (tiposSnap.puntoMedio && forma.puntos.length > 1) {
                            for (let i = 0; i < forma.puntos.length - 1; i++) {
                                snapPuntos.push({
                                    x: (forma.puntos[i].x + forma.puntos[i+1].x) / 2,
                                    y: (forma.puntos[i].y + forma.puntos[i+1].y) / 2,
                                    tipo: "punto medio", formaId: forma.id
                                });
                            }
                        }
                    }
                    break;
                case "arco":
                    if (tiposSnap.puntoFinal) {
                        snapPuntos.push({ x: forma.x1, y: forma.y1, tipo: "punto final", formaId: forma.id });
                        snapPuntos.push({ x: forma.x2, y: forma.y2, tipo: "punto final", formaId: forma.id });
                    }
                    // Snap a punto medio del arco es más complejo, omitido por ahora
                    break;
            }
        });
    },

    iniciarDibujo(x, y, dobleClic) {
        // Si estamos en modo 3D, no hacemos nada aquí
        if (isDrawing3D) return;

        // Ajustar las coordenadas al snap si está activo
        const adjustedPoint = Utilidades.aplicarSnap(x, y);
        x = adjustedPoint.x;
        y = adjustedPoint.y;

        // Iniciar el dibujo según el modo actual
        if (modoActual === "linea" || modoActual === "rectangulo" || modoActual === "circulo" || modoActual === "elipse") {
            if (!dibujando) {
                puntoInicial = { x, y };
                dibujando = true;
                xAnterior = x;
                yAnterior = y;
                Utilidades.mostrarMensajeTemporalEstado("Punto inicial seleccionado. Haz clic para finalizar.");
            }
        } else if (modoActual === "polilinea") {
            if (!dibujando) {
                puntoInicial = { x, y };
                dibujando = true;
                xAnterior = x;
                yAnterior = y;
                Utilidades.mostrarMensajeTemporalEstado("Polilínea iniciada. Haz clic para añadir puntos, doble clic para finalizar.");
            } else if (dobleClic) {
                // Doble clic finaliza la polilínea
                puntoInicial = null;
                dibujando = false;
                Utilidades.mostrarMensajeTemporalEstado("Polilínea finalizada.");
            }
        }

        Canvas2D.dibujar();
    },

    finalizarDibujoEn(x, y) {
        if (!puntoInicial) return;

        const puntoFinalOriginal = { x, y };
        const puntoFinal = restriccionAngulo
            ? Utilidades.restringirAngulo(puntoInicial.x, puntoInicial.y, x, y)
            : puntoFinalOriginal;

        let nuevaForma = null;
        ctx.strokeStyle = Config.COLOR_LINEA_DEFAULT;
        ctx.lineWidth = 1.5 / zoomLevel;

        console.log("Finalizar dibujo - Inicial:", puntoInicial, "Final:", puntoFinal);

        switch (modoActual) {
            case "linea":
                nuevaForma = {
                    id: Utilidades.generarIdUnico(),
                    tipo: "linea",
                    x1: puntoInicial.x,
                    y1: puntoInicial.y,
                    x2: puntoFinal.x,
                    y2: puntoFinal.y,
                    color: Config.COLOR_LINEA_DEFAULT,
                };
                Canvas2D.dibujarLinea(puntoInicial.x, puntoInicial.y, puntoFinal.x, puntoFinal.y);
                Utilidades.mostrarMensajeTemporalEstado("Línea creada");
                break;

            case "polilinea":
                nuevaForma = {
                    id: Utilidades.generarIdUnico(),
                    tipo: "linea", // Cada segmento es una línea
                    x1: puntoInicial.x,
                    y1: puntoInicial.y,
                    x2: puntoFinal.x,
                    y2: puntoFinal.y,
                    color: Config.COLOR_LINEA_DEFAULT,
                };
                Canvas2D.dibujarLinea(puntoInicial.x, puntoInicial.y, puntoFinal.x, puntoFinal.y);
                Utilidades.mostrarMensajeTemporalEstado("Segmento de polilínea creado");
                puntoInicial = { x: puntoFinal.x, y: puntoFinal.y }; // Continuar desde el punto final
                break;

            case "rectangulo":
                const ancho = puntoFinal.x - puntoInicial.x;
                const alto = puntoFinal.y - puntoInicial.y;
                nuevaForma = {
                    id: Utilidades.generarIdUnico(),
                    tipo: "rectangulo",
                    x: puntoInicial.x,
                    y: puntoInicial.y,
                    ancho: ancho,
                    alto: alto,
                    color: Config.COLOR_LINEA_DEFAULT,
                };
                Canvas2D.dibujarRectangulo(puntoInicial.x, puntoInicial.y, ancho, alto);
                Utilidades.mostrarMensajeTemporalEstado("Rectángulo creado");
                break;

            case "circulo":
                const radio = Utilidades.calcularDistancia(puntoInicial.x, puntoInicial.y, puntoFinal.x, puntoFinal.y);
                nuevaForma = {
                    id: Utilidades.generarIdUnico(),
                    tipo: "circulo",
                    x: puntoInicial.x,
                    y: puntoInicial.y,
                    radio: radio,
                    color: Config.COLOR_LINEA_DEFAULT,
                };
                Canvas2D.dibujarCirculo(puntoInicial.x, puntoInicial.y, radio);
                Utilidades.mostrarMensajeTemporalEstado("Círculo creado");
                break;

            case "elipse":
                const radiusX = Math.abs(puntoFinal.x - puntoInicial.x) / 2;
                const radiusY = Math.abs(puntoFinal.y - puntoInicial.y) / 2;
                const centroX = puntoInicial.x + (puntoFinal.x - puntoInicial.x) / 2;
                const centroY = puntoInicial.y + (puntoFinal.y - puntoInicial.y) / 2;
                nuevaForma = {
                    id: Utilidades.generarIdUnico(),
                    tipo: "elipse",
                    x: centroX,
                    y: centroY,
                    radiusX: radiusX,
                    radiusY: radiusY,
                    color: Config.COLOR_LINEA_DEFAULT,
                };
                Canvas2D.dibujarElipse(centroX, centroY, radiusX, radiusY);
                Utilidades.mostrarMensajeTemporalEstado("Elipse creada");
                break;
        }

        if (nuevaForma) {
            formas.push(nuevaForma);
            this.actualizarVista3D(nuevaForma);
            this.actualizarSnapPuntos();
            Canvas2D.guardarEstado();
        }

        if (modoActual !== "polilinea") {
            puntoInicial = null;
            Canvas2D.ocultarIndicadoresVisuales();
            dibujando = false;
        }

        Canvas2D.dibujar();
    },
};

        encontrarSnapPunto(mouseX, mouseY) {
            let mejorSnap = { encontrado: false, x: mouseX, y: mouseY, tipo: "" };
            if (!snapActivo && !snapToGridActivo) return mejorSnap;

            let distanciaMinima = Infinity;
            const radioPx = Config.SNAP_RADIUS / zoomLevel; // Radio de snap en coordenadas del canvas

            // 1. Snap a la rejilla (si está activo)
            if (snapToGridActivo) {
                 const puntoRejilla = Utilidades.ajustarARejilla(mouseX, mouseY);
                 const distRejilla = Utilidades.calcularDistancia(mouseX, mouseY, puntoRejilla.x, puntoRejilla.y);
                 if (distRejilla < radioPx && distRejilla < distanciaMinima) {
                     distanciaMinima = distRejilla;
                     mejorSnap = { encontrado: true, x: puntoRejilla.x, y: puntoRejilla.y, tipo: "rejilla" };
                 }
            }

            // 2. Snap a objetos (si está activo)
            if (snapActivo) {
                snapPuntos.forEach(punto => {
                    if (!tiposSnap[punto.tipo.replace(' ', '')]) return; // Verificar si el tipo de snap está habilitado

                    const distancia = Utilidades.calcularDistancia(mouseX, mouseY, punto.x, punto.y);
                    if (distancia < radioPx && distancia < distanciaMinima) {
                        distanciaMinima = distancia;
                        mejorSnap = { encontrado: true, x: punto.x, y: punto.y, tipo: punto.tipo };
                    }
                });
            }

            // Mostrar información de snap en la UI
            if (snapInfoElement) {
                snapInfoElement.textContent = mejorSnap.encontrado ? `Snap: ${mejorSnap.tipo}` : "";
                snapInfoElement.style.color = mejorSnap.encontrado ? Config.COLOR_SNAP : 'white';
            }

            return mejorSnap;
        },

        dibujarSnapIndicador(x, y, tipo) {
            ctx.save();
            ctx.fillStyle = Config.COLOR_SNAP;
            ctx.strokeStyle = Config.COLOR_SNAP;
            ctx.lineWidth = 1 / zoomLevel;
            const size = 8 / zoomLevel; // Tamaño del indicador en canvas coords

            ctx.beginPath();
            switch (tipo) {
                case 'punto final':
                    ctx.rect(x - size / 2, y - size / 2, size, size); // Cuadrado
                    break;
                case 'punto medio':
                    ctx.moveTo(x, y - size / 2); // Triángulo
                    ctx.lineTo(x + size / 2, y + size / 2);
                    ctx.lineTo(x - size / 2, y + size / 2);
                    ctx.closePath();
                    break;
                case 'centro':
                    ctx.arc(x, y, size / 2, 0, Math.PI * 2); // Círculo
                    break;
                case 'cuadrante':
                     ctx.moveTo(x - size / 2, y - size / 2); // Rombo
                     ctx.lineTo(x + size / 2, y);
                     ctx.lineTo(x - size / 2, y + size / 2);
                     ctx.lineTo(x - size / 2, y - size / 2);
                     ctx.closePath();
                    break;
                case 'rejilla':
                    ctx.arc(x, y, size / 3, 0, Math.PI * 2); // Círculo pequeño
                     ctx.moveTo(x - size/2, y); ctx.lineTo(x + size/2, y); // Cruz
                     ctx.moveTo(x, y - size/2); ctx.lineTo(x, y + size/2);
                    break;
                default:
                    ctx.arc(x, y, size / 1.5, 0, Math.PI * 2); // Círculo más grande por defecto
                    break;
            }
             if (tipo === 'centro' || tipo === 'rejilla' || tipo === 'cuadrante') {
                 ctx.stroke(); // Solo contorno para algunos
             } else {
                 ctx.fill(); // Relleno para otros
             }
            ctx.restore();
        },

        // --- Lógica de Polilínea ---
        iniciarPolilinea(x, y) {
            dibujarPolilineaEnProgreso = true;
            puntosPolilinea = [{ x, y }];
            this.dibujarMarcadorPunto(x, y, Config.COLOR_SNAP); // Marcar inicio
            Utilidades.mostrarMensajeTemporalEstado("Polilínea iniciada. Clic para añadir puntos, Doble clic o ESC para finalizar.");
            canvas.setAttribute('aria-label', 'Dibujando polilínea. Primer punto establecido.');
        },

        continuarPolilinea(x, y) {
            if (!dibujarPolilineaEnProgreso || puntosPolilinea.length === 0) return;

            const ultimoPunto = puntosPolilinea[puntosPolilinea.length - 1];
            ctx.beginPath();
            ctx.strokeStyle = Config.COLOR_LINEA_DEFAULT;
            ctx.lineWidth = 1.5 / zoomLevel;
            ctx.moveTo(ultimoPunto.x, ultimoPunto.y);
            ctx.lineTo(x, y);
            ctx.stroke();

            puntosPolilinea.push({ x, y });
            this.dibujarMarcadorPunto(x, y); // Marcar punto añadido

            Canvas2D.guardarEstadoParcial(); // Guardar estado sin añadir al historial principal aún
            canvas.setAttribute('aria-label', `Punto añadido a polilínea. Total: ${puntosPolilinea.length}`);
        },

        finalizarPolilinea() {
            if (!dibujarPolilineaEnProgreso || puntosPolilinea.length < 2) {
                dibujarPolilineaEnProgreso = false;
                puntosPolilinea = [];
                Canvas2D.restaurarEstado(); // Limpiar líneas temporales si se cancela
                Utilidades.mostrarMensajeTemporalEstado("Polilínea cancelada (pocos puntos)");
                return;
            }

            const nuevaForma = {
                id: Utilidades.generarIdUnico(),
                tipo: "polilinea",
                puntos: [...puntosPolilinea], // Copiar array
                color: Config.COLOR_LINEA_DEFAULT
            };
            formas.push(nuevaForma);

            this.actualizarRepresentacion3D(nuevaForma);
            this.actualizarSnapPuntos();
            Canvas2D.guardarEstado(); // Guardar estado final en el historial

            dibujarPolilineaEnProgreso = false;
            puntosPolilinea = [];
            Utilidades.mostrarMensajeTemporalEstado("Polilínea completada");
            canvas.setAttribute('aria-label', 'Polilínea finalizada');
        },

        // --- Lógica de Arco ---
        iniciarArco(x, y) {
            dibujarArcoEnProgreso = true;
            puntosArco = [{ x, y }]; // Punto inicial
            this.dibujarMarcadorPunto(x, y, Config.COLOR_SNAP);
            Utilidades.mostrarMensajeTemporalEstado("Arco: Defina punto de control.");
            canvas.setAttribute('aria-label', 'Dibujando arco. Primer punto establecido.');
        },

        continuarArco(x, y) {
            if (!dibujarArcoEnProgreso) return;

            if (puntosArco.length === 1) { // Definiendo punto de control
                puntosArco.push({ x, y });
                this.dibujarMarcadorPunto(x, y, '#00ff00'); // Punto control en verde
                // Dibujar línea guía
                ctx.beginPath();
                ctx.setLineDash([3 / zoomLevel, 2 / zoomLevel]);
                ctx.strokeStyle = '#00ff00';
                ctx.lineWidth = 1 / zoomLevel;
                ctx.moveTo(puntosArco[0].x, puntosArco[0].y);
                ctx.lineTo(x, y);
                ctx.stroke();
                ctx.setLineDash([]);
                Canvas2D.guardarEstadoParcial();
                Utilidades.mostrarMensajeTemporalEstado("Arco: Defina punto final.");
                canvas.setAttribute('aria-label', 'Dibujando arco. Punto de control establecido.');

            } else if (puntosArco.length === 2) { // Definiendo punto final
                puntosArco.push({ x, y }); // Punto final
                ctx.beginPath();
                ctx.strokeStyle = Config.COLOR_LINEA_DEFAULT;
                ctx.lineWidth = 1.5 / zoomLevel;
                ctx.moveTo(puntosArco[0].x, puntosArco[0].y);
                ctx.quadraticCurveTo(puntosArco[1].x, puntosArco[1].y, x, y);
                ctx.stroke();

                const nuevaForma = {
                    id: Utilidades.generarIdUnico(), tipo: "arco",
                    x1: puntosArco[0].x, y1: puntosArco[0].y,
                    cx: puntosArco[1].x, cy: puntosArco[1].y,
                    x2: x, y2: y,
                    color: Config.COLOR_LINEA_DEFAULT
                };
                formas.push(nuevaForma);

                this.actualizarRepresentacion3D(nuevaForma);
                this.actualizarSnapPuntos();
                Canvas2D.guardarEstado();

                dibujarArcoEnProgreso = false;
                puntosArco = [];
                Utilidades.mostrarMensajeTemporalEstado("Arco completado");
                canvas.setAttribute('aria-label', 'Arco finalizado');
            }
        },

         // --- Lógica de Mano Alzada ---
         iniciarManoAlzada(x, y) {
             dibujando = true;
             xAnterior = x;
             yAnterior = y;
             puntosPolilinea = [{ x, y }]; // Usar puntosPolilinea para almacenar trazo
             ctx.beginPath();
             ctx.strokeStyle = Config.COLOR_LINEA_DEFAULT;
             ctx.lineWidth = 1.5 / zoomLevel;
             ctx.moveTo(x, y);
         },

         continuarManoAlzada(x, y) {
             if (!dibujando) return;
             ctx.lineTo(x, y);
             ctx.stroke();
             puntosPolilinea.push({ x, y });
             xAnterior = x;
             yAnterior = y;
         },

         finalizarManoAlzada() {
             if (!dibujando) return;
             dibujando = false;
             if (puntosPolilinea.length > 1) {
                 // Simplificar la polilínea si es necesario (opcional)
                 // ...

                 const nuevaForma = {
                     id: Utilidades.generarIdUnico(),
                     tipo: "polilinea", // Guardar como polilínea
                     puntos: [...puntosPolilinea],
                     color: Config.COLOR_LINEA_DEFAULT
                 };
                 formas.push(nuevaForma);
                 this.actualizarRepresentacion3D(nuevaForma);
                 this.actualizarSnapPuntos();
                 Canvas2D.guardarEstado();
                 Utilidades.mostrarMensajeTemporalEstado("Trazo a mano alzada completado");
             }
             puntosPolilinea = [];
         },

        // --- Dimensionamiento Manual ---
        activarDimensionManual() {
             if (!puntoInicial) {
                 Utilidades.mostrarMensajeTemporalEstado("Primero defina el punto inicial");
                 return;
             }
             dimensionManualActiva = true;
             entradaDimensionesElement.style.display = "block";
             inputDistanciaElement.focus();
             inputDistanciaElement.value = Utilidades.formatearNumero(Utilidades.calcularDistancia(puntoInicial.x, puntoInicial.y, xAnterior, yAnterior)); // Usar última posición del cursor
             Utilidades.mostrarMensajeTemporalEstado("Introduzca la distancia y presione Aplicar o Enter");
        },

        aplicarDimensionManual() {
            if (!puntoInicial || !dimensionManualActiva) return;

            const distancia = parseFloat(inputDistanciaElement.value);
            if (isNaN(distancia) || distancia <= 0) {
                Utilidades.mostrarMensajeTemporalEstado("Distancia inválida");
                inputDistanciaElement.focus();
                return;
            }

            // Usar el ángulo actual (calculado en mousemove)
            const anguloRad = anguloActual * Math.PI / 180;
            const x2 = puntoInicial.x + Math.cos(anguloRad) * distancia;
            const y2 = puntoInicial.y + Math.sin(anguloRad) * distancia;

            // Finalizar el dibujo con las coordenadas calculadas
            this.finalizarDibujoEn(x2, y2);

            // Resetear estado de dimensión manual
            dimensionManualActiva = false;
            entradaDimensionesElement.style.display = "none";
            const btnDimension = document.getElementById("btnDimension");
            if (btnDimension) {
                 btnDimension.classList.remove("active");
                 btnDimension.setAttribute('aria-pressed', 'false');
            }
        },

        // --- Ayudantes de Dibujo ---
        dibujarMarcadorPunto(x, y, color = '#ff0000') {
            ctx.save();
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(x, y, 4 / zoomLevel, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        },

        // --- Sincronización 3D ---
        // Convierte coordenadas 2D del canvas al sistema de coordenadas 3D (Z=0)
        mapCoords2Dto3D(x2d, y2d) {
            // Asumiendo que el origen (0,0) del canvas 2D corresponde a (0,0,0) en 3D
            // Ajustar si el origen 2D es diferente (e.g., centro del canvas)
             const origenX_2D = canvas.width / 2; // Si el origen 2D está en el centro
             const origenY_2D = canvas.height / 2;
             // return new THREE.Vector3(x2d - origenX_2D, -(y2d - origenY_2D), 0); // Invertir Y
             return new THREE.Vector3(x2d, -y2d, 0); // Asumiendo origen 2D en (0,0) y mapeo directo X->X, Y->-Y
        },

        actualizarRepresentacion3D(forma2D) {
            if (!escena3DInitializada || !scene) return;

             // Eliminar representación 3D anterior de esta forma si existe
             const objetosAEliminar = scene.children.filter(child => child.userData?.formaId === forma2D.id);
             objetosAEliminar.forEach(obj => {
                 scene.remove(obj);
                 if (obj.geometry) obj.geometry.dispose();
                 if (obj.material) obj.material.dispose();
             });

            // Crear nueva representación 3D
            const material = new THREE.LineBasicMaterial({ color: forma2D.color || Config.COLOR_LINEA_3D });
            let geometry;
            let lineObject;

            switch (forma2D.tipo) {
                case "linea":
                    geometry = new THREE.BufferGeometry().setFromPoints([
                        this.mapCoords2Dto3D(forma2D.x1, forma2D.y1),
                        this.mapCoords2Dto3D(forma2D.x2, forma2D.y2)
                    ]);
                    lineObject = new THREE.Line(geometry, material);
                    break;
                case "rectangulo":
                    const p1 = this.mapCoords2Dto3D(forma2D.x, forma2D.y);
                    const p2 = this.mapCoords2Dto3D(forma2D.x + forma2D.ancho, forma2D.y);
                    const p3 = this.mapCoords2Dto3D(forma2D.x + forma2D.ancho, forma2D.y + forma2D.alto);
                    const p4 = this.mapCoords2Dto3D(forma2D.x, forma2D.y + forma2D.alto);
                    geometry = new THREE.BufferGeometry().setFromPoints([p1, p2, p3, p4, p1]); // Cerrar el rectángulo
                    lineObject = new THREE.Line(geometry, material);
                    break;
                case "polilinea":
                     if (forma2D.puntos && forma2D.puntos.length > 1) {
                         const points3D = forma2D.puntos.map(p => this.mapCoords2Dto3D(p.x, p.y));
                         geometry = new THREE.BufferGeometry().setFromPoints(points3D);
                         lineObject = new THREE.Line(geometry, material); // THREE.Line para polilíneas abiertas
                     }
                    break;
                 case "circulo":
                     const segments = 64; // Mayor número para círculo más suave
                     const pointsCircle = [];
                     for (let i = 0; i <= segments; i++) {
                         const theta = (i / segments) * Math.PI * 2;
                         const x = forma2D.x + forma2D.radio * Math.cos(theta);
                         const y = forma2D.y + forma2D.radio * Math.sin(theta);
                         pointsCircle.push(this.mapCoords2Dto3D(x, y));
                     }
                     geometry = new THREE.BufferGeometry().setFromPoints(pointsCircle);
                     lineObject = new THREE.LineLoop(geometry, material); // LineLoop para cerrar el círculo
                     break;
                // Añadir casos para elipse, arco si se desea visualización 3D
                default:
                    return; // No visualizar otros tipos por ahora
            }

            if (lineObject) {
                lineObject.userData.formaId = forma2D.id; // Vincular objeto 3D a la forma 2D
                scene.add(lineObject);
            }
        },

        // Actualiza TODAS las representaciones 3D basadas en el array `formas`
        actualizarTodasLasLineas3D() {
            if (!escena3DInitializada || !scene) return;

            // Eliminar todas las líneas 3D derivadas de 2D
            const objetosAEliminar = scene.children.filter(child => child.userData?.formaId);
            objetosAEliminar.forEach(obj => {
                scene.remove(obj);
                if (obj.geometry) obj.geometry.dispose();
                if (obj.material) obj.material.dispose();
            });

            // Volver a crear todas las representaciones 3D
            formas.forEach(forma => this.actualizarRepresentacion3D(forma));
        }
    };

    // =========================================================================
    // Módulo de Canvas 2D (Manejo del lienzo y dibujado base)
    // =========================================================================
const Canvas2D = {
    inicializar() {
        canvas = document.getElementById("lienzo");
        if (!canvas) {
            console.error("Elemento canvas 'lienzo' no encontrado.");
            Utilidades.mostrarMensajeTemporalEstado("Error: Canvas no encontrado.", 5000);
            return false;
        }
        // Establecer dimensiones iniciales del canvas
        canvas.width = 800;  // Añadido para asegurar un tamaño funcional
        canvas.height = 500;
        ctx = canvas.getContext("2d", { willReadFrequently: true });
        if (!ctx) {
            console.error("No se pudo obtener el contexto 2D del canvas.");
            Utilidades.mostrarMensajeTemporalEstado("Error: Contexto 2D no disponible.", 5000);
            return false;
        }

        // Inicializar elementos UI
        coordsElement = document.getElementById("coordCanvas");
        snapInfoElement = document.getElementById("snapInfo");
        lineInfoElement = document.getElementById("lineInfo");
        entradaDimensionesElement = document.getElementById("entradaDimensiones");
        inputDistanciaElement = document.getElementById("inputDistancia");
        inputXElement = document.getElementById("inputX");
        inputYElement = document.getElementById("inputY");
        originIndicator2D = document.getElementById("originIndicator2D");
        originLabel2D = document.getElementById("originLabel2D");
        distanciaVisualElement = document.getElementById("distanciaVisual");
        anguloVisualElement = document.getElementById("anguloVisual");
        ortoVisualElement = document.getElementById("ortoVisual");
        anguloInfoElement = document.getElementById("anguloInfoElement");
        btnToggle3D = document.getElementById("btnToggle3D");

        // Verificar elementos UI críticos
        if (!coordsElement || !lineInfoElement) {
            console.warn("Algunos elementos UI no están disponibles. La interfaz puede no funcionar completamente.");
        }

        // Configuración inicial del canvas
        this.resetearTransformacion();
        this.aplicarTransformacion();
        ctx.lineWidth = 1.5 / zoomLevel;
        ctx.strokeStyle = Config.COLOR_LINEA_DEFAULT;
        ctx.fillStyle = Config.COLOR_SNAP;
        ctx.lineCap = "round";
        ctx.lineJoin = "round";

        this.inicializarPanoramica();
        this.inicializarZoom();
        this.redibujaTodo();
        this.guardarEstado();

        // Añadir atributos ARIA
        canvas.setAttribute("aria-roledescription", "editor CAD 2D");
        canvas.setAttribute("aria-label", "Área de dibujo CAD 2D. Use las herramientas o atajos para dibujar.");

        console.log("Canvas 2D inicializado.");
        return true;
    },

    resetearTransformacion() {
        zoomLevel = 1;
        panX = canvas ? canvas.width / 2 : 0;
        panY = canvas ? canvas.height / 2 : 0;
    },

    aplicarTransformacion() {
        if (!ctx) return;
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.translate(panX, panY);
        ctx.scale(zoomLevel, zoomLevel);
    },

    inicializarPanoramica() {
        if (!canvas) return;
        const handleMouseDown = (e) => {
            if (e.button === 1) {
                isPanning = true;
                startPanX = e.clientX;
                startPanY = e.clientY;
                canvas.style.cursor = "grabbing";
                e.preventDefault();
            }
        };

        const handleMouseMove = (e) => {
            if (!isPanning) return;
            const dx = e.clientX - startPanX;
            const dy = e.clientY - startPanY;
            panX += dx;
            panY += dy;
            startPanX = e.clientX;
            startPanY = e.clientY;
            this.aplicarTransformacion();
            this.redibujaTodo();
            this.actualizarIndicadorOrigen(); // Añadido para mantener el indicador consistente
        };

        const handleMouseUp = (e) => {
            if (e.button === 1 && isPanning) {
                isPanning = false;
                canvas.style.cursor = "crosshair";
            }
        };

        const handleMouseLeave = () => {
            if (isPanning) {
                isPanning = false;
                canvas.style.cursor = "crosshair";
            }
        };

        const handleContextMenu = (e) => e.preventDefault();

        canvas.addEventListener("mousedown", handleMouseDown);
        canvas.addEventListener("mousemove", handleMouseMove);
        canvas.addEventListener("mouseup", handleMouseUp);
        canvas.addEventListener("mouseleave", handleMouseLeave);
        canvas.addEventListener("contextmenu", handleContextMenu);

        // Guardar referencias para limpieza
        this.panEventListeners = {
            mousedown: handleMouseDown,
            mousemove: handleMouseMove,
            mouseup: handleMouseUp,
            mouseleave: handleMouseLeave,
            contextmenu: handleContextMenu
        };
    },

    inicializarZoom() {
        if (!canvas) return;
        const handleWheel = (e) => {
            e.preventDefault();
            const delta = e.deltaY > 0 ? -1 : 1;
            const factorZoom = 1 + delta * Config.ZOOM_SPEED;
            const nuevoZoom = Math.max(Config.MIN_ZOOM, Math.min(Config.MAX_ZOOM, zoomLevel * factorZoom));

            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            const pointAntesX = (mouseX - panX) / zoomLevel;
            const pointAntesY = (mouseY - panY) / zoomLevel;

            zoomLevel = nuevoZoom;
            panX = mouseX - pointAntesX * zoomLevel;
            panY = mouseY - pointAntesY * zoomLevel;

            this.aplicarTransformacion();
            this.redibujaTodo();
            this.actualizarIndicadorOrigen(); // Añadido para mantener el indicador consistente
            this.actualizarInfoZoom();
        };

        canvas.addEventListener("wheel", handleWheel, { passive: false });

        // Guardar referencia para limpieza
        this.zoomEventListeners = { wheel: handleWheel };

        // Botones de Zoom
        Utilidades.registrarEventos("zoomIn", { click: () => this.zoomBoton(1) });
        Utilidades.registrarEventos("zoomOut", { click: () => this.zoomBoton(-1) });
        Utilidades.registrarEventos("zoomFit", { click: () => this.resetearVista() });
    },

    zoomBoton(direccion) {
        if (!canvas) return;
        const factorZoom = 1 + direccion * Config.ZOOM_SPEED * 2;
        const nuevoZoom = Math.max(Config.MIN_ZOOM, Math.min(Config.MAX_ZOOM, zoomLevel * factorZoom));

        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        const pointAntesX = (centerX - panX) / zoomLevel;
        const pointAntesY = (centerY - panY) / zoomLevel;

        zoomLevel = nuevoZoom;
        panX = centerX - pointAntesX * zoomLevel;
        panY = centerY - pointAntesY * zoomLevel;

        this.aplicarTransformacion();
        this.redibujaTodo();
        this.actualizarIndicadorOrigen(); // Añadido para mantener el indicador consistente
        this.actualizarInfoZoom();
        Utilidades.mostrarMensajeTemporalEstado(`Zoom ${direccion > 0 ? "acercado" : "alejado"}`);
    },

    resetearVista() {
        if (!canvas || !ctx) return;
        this.resetearTransformacion();
        this.aplicarTransformacion();
        this.redibujaTodo();
        this.actualizarIndicadorOrigen(); // Añadido para mantener el indicador consistente
        this.actualizarInfoZoom();
        Utilidades.mostrarMensajeTemporalEstado("Vista 2D reseteada");
        canvas.setAttribute("aria-label", "Área de dibujo CAD 2D. Zoom reseteado.");
    },

    redibujaTodo() {
        if (!ctx || !canvas) return;
        const transformActual = ctx.getTransform();
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = Config.COLOR_FONDO_2D;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.setTransform(transformActual);

        if (rejillaActiva) this.dibujarRejilla();
        this.dibujarEjes();
        this.dibujarFormas();
        this.actualizarIndicadorOrigen();
    },

    dibujarRejilla() {
        if (!ctx) return;
        ctx.save();
        ctx.strokeStyle = Config.COLOR_REJILLA_2D;
        ctx.lineWidth = 0.5 / zoomLevel;

        const tamanoRejilla = Config.TAMANO_REJILLA_2D;
        const topLeft = Utilidades.screenToCanvas(0, 0);
        const bottomRight = Utilidades.screenToCanvas(canvas.width, canvas.height);

        const xStart = Math.floor(topLeft.x / tamanoRejilla) * tamanoRejilla;
        const xEnd = Math.ceil(bottomRight.x / tamanoRejilla) * tamanoRejilla;
        for (let x = xStart; x <= xEnd; x += tamanoRejilla) {
            ctx.beginPath();
            ctx.moveTo(x, topLeft.y);
            ctx.lineTo(x, bottomRight.y);
            ctx.stroke();
        }

        const yStart = Math.floor(topLeft.y / tamanoRejilla) * tamanoRejilla;
        const yEnd = Math.ceil(bottomRight.y / tamanoRejilla) * tamanoRejilla;
        for (let y = yStart; y <= yEnd; y += tamanoRejilla) {
            ctx.beginPath();
            ctx.moveTo(topLeft.x, y);
            ctx.lineTo(bottomRight.x, y);
            ctx.stroke();
        }

        ctx.restore();
    },

    dibujarEjes() {
        if (!ctx) return;
        ctx.save();
        ctx.strokeStyle = Config.COLOR_EJES_2D;
        ctx.lineWidth = 1 / zoomLevel;

        const topLeft = Utilidades.screenToCanvas(0, 0);
        const bottomRight = Utilidades.screenToCanvas(canvas.width, canvas.height);

        ctx.beginPath();
        ctx.moveTo(topLeft.x, 0);
        ctx.lineTo(bottomRight.x, 0);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(0, topLeft.y);
        ctx.lineTo(0, bottomRight.y);
        ctx.stroke();

        ctx.restore();
    },

    dibujarFormas() {
        if (!ctx) return;
        ctx.save();
        ctx.lineWidth = 1.5 / zoomLevel;

        formas.forEach(forma => {
            ctx.strokeStyle = forma.color || Config.COLOR_LINEA_DEFAULT;
            ctx.beginPath();
            switch (forma.tipo) {
                case "linea":
                    ctx.moveTo(forma.x1, forma.y1);
                    ctx.lineTo(forma.x2, forma.y2);
                    break;
                case "rectangulo":
                    ctx.rect(forma.x, forma.y, forma.ancho, forma.alto);
                    break;
                case "circulo":
                    ctx.arc(forma.x, forma.y, forma.radio, 0, Math.PI * 2);
                    break;
                case "elipse":
                    ctx.ellipse(forma.x, forma.y, forma.radiusX, forma.radiusY, 0, 0, Math.PI * 2);
                    break;
                case "polilinea": // Añadido para soportar polilíneas
                    if (forma.puntos && forma.puntos.length > 1) {
                        ctx.moveTo(forma.puntos[0].x, forma.puntos[0].y);
                        for (let i = 1; i < forma.puntos.length; i++) {
                            ctx.lineTo(forma.puntos[i].x, forma.puntos[i].y);
                        }
                    }
                    break;
                case "arco": // Añadido para soportar arcos
                    ctx.moveTo(forma.x1, forma.y1);
                    ctx.quadraticCurveTo(forma.cx, forma.cy, forma.x2, forma.y2);
                    break;
            }
            ctx.stroke();
        });

        ctx.restore();
    },

    dibujarLinea(x1, y1, x2, y2, esVistaPrevia = false) {
        if (!ctx) return;
        ctx.save();
        ctx.beginPath();
        ctx.strokeStyle = esVistaPrevia ? Config.COLOR_VISTAPREVIA : Config.COLOR_LINEA_DEFAULT;
        ctx.lineWidth = esVistaPrevia ? 1 / zoomLevel : 1.5 / zoomLevel;
        if (esVistaPrevia) ctx.setLineDash([5 / zoomLevel, 3 / zoomLevel]);
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.restore();
    },

    dibujarRectangulo(x, y, ancho, alto) {
        if (!ctx) return;
        ctx.save();
        ctx.beginPath();
        ctx.strokeStyle = Config.COLOR_LINEA_DEFAULT;
        ctx.lineWidth = 1.5 / zoomLevel;
        ctx.rect(x, y, ancho, alto);
        ctx.stroke();
        ctx.restore();
    },

    dibujarCirculo(x, y, radio) {
        if (!ctx) return;
        ctx.save();
        ctx.beginPath();
        ctx.strokeStyle = Config.COLOR_LINEA_DEFAULT;
        ctx.lineWidth = 1.5 / zoomLevel;
        ctx.arc(x, y, radio, 0, Math.PI * 2);
        ctx.stroke();
        ctx.restore();
    },

    dibujarElipse(x, y, radiusX, radiusY) {
        if (!ctx) return;
        ctx.save();
        ctx.beginPath();
        ctx.strokeStyle = Config.COLOR_LINEA_DEFAULT;
        ctx.lineWidth = 1.5 / zoomLevel;
        ctx.ellipse(x, y, radiusX, radiusY, 0, 0, Math.PI * 2);
        ctx.stroke();
        ctx.restore();
    },

    dibujarLineaTemporal(x1, y1, x2, y2) {
        this.dibujarLinea(x1, y1, x2, y2, true);
    },

    dibujarPreviewForma(x, y) {
        if (!ctx || !puntoInicial) return;
        const puntoFinalOriginal = { x, y };
        const puntoFinal = restriccionAngulo
            ? Utilidades.restringirAngulo(puntoInicial.x, puntoInicial.y, x, y)
            : puntoFinalOriginal;

        switch (modoActual) { // Añadido para soportar todas las formas en la vista previa
            case "linea":
            case "polilinea":
                this.dibujarLineaTemporal(puntoInicial.x, puntoInicial.y, puntoFinal.x, puntoFinal.y);
                break;
            case "rectangulo":
                const ancho = puntoFinal.x - puntoInicial.x;
                const alto = puntoFinal.y - puntoInicial.y;
                ctx.save();
                ctx.beginPath();
                ctx.strokeStyle = Config.COLOR_VISTAPREVIA;
                ctx.lineWidth = 1 / zoomLevel;
                ctx.setLineDash([5 / zoomLevel, 3 / zoomLevel]);
                ctx.rect(puntoInicial.x, puntoInicial.y, ancho, alto);
                ctx.stroke();
                ctx.setLineDash([]);
                ctx.restore();
                break;
            case "circulo":
                const radio = Utilidades.calcularDistancia(puntoInicial.x, puntoInicial.y, puntoFinal.x, puntoFinal.y);
                ctx.save();
                ctx.beginPath();
                ctx.strokeStyle = Config.COLOR_VISTAPREVIA;
                ctx.lineWidth = 1 / zoomLevel;
                ctx.setLineDash([5 / zoomLevel, 3 / zoomLevel]);
                ctx.arc(puntoInicial.x, puntoInicial.y, radio, 0, Math.PI * 2);
                ctx.stroke();
                ctx.setLineDash([]);
                ctx.restore();
                break;
            case "elipse":
                const radiusX = Math.abs(puntoFinal.x - puntoInicial.x) / 2;
                const radiusY = Math.abs(puntoFinal.y - puntoInicial.y) / 2;
                const centroX = puntoInicial.x + (puntoFinal.x - puntoInicial.x) / 2;
                const centroY = puntoInicial.y + (puntoFinal.y - puntoInicial.y) / 2;
                ctx.save();
                ctx.beginPath();
                ctx.strokeStyle = Config.COLOR_VISTAPREVIA;
                ctx.lineWidth = 1 / zoomLevel;
                ctx.setLineDash([5 / zoomLevel, 3 / zoomLevel]);
                ctx.ellipse(centroX, centroY, radiusX, radiusY, 0, 0, Math.PI * 2);
                ctx.stroke();
                ctx.setLineDash([]);
                ctx.restore();
                break;
        }
        this.mostrarIndicadoresVisuales(puntoInicial.x, puntoInicial.y, puntoFinal.x, puntoFinal.y);
    },

    mostrarIndicadoresVisuales(x1, y1, x2, y2) {
        const screenP1 = Utilidades.canvasToScreen(x1, y1);
        const screenP2 = Utilidades.canvasToScreen(x2, y2);
        const midScreenX = (screenP1.x + screenP2.x) / 2;
        const midScreenY = (screenP1.y + screenP2.y) / 2;

        const distancia = Utilidades.calcularDistancia(x1, y1, x2, y2);
        if (distanciaVisualElement) {
            distanciaVisualElement.textContent = Utilidades.formatearNumero(distancia);
            distanciaVisualElement.style.left = `${midScreenX + 5}px`;
            distanciaVisualElement.style.top = `${midScreenY - 15}px`;
            distanciaVisualElement.style.display = "block";
        }

        anguloActual = Utilidades.calcularAngulo(x1, y1, x2, y2);
        if (lineInfoElement) {
            lineInfoElement.textContent = `Long: ${Utilidades.formatearNumero(distancia)} | Áng: ${Utilidades.formatearNumero(anguloActual, 1)}°`;
        }
        if (anguloVisualElement) { // Añadido para mostrar el ángulo en pantalla
            anguloVisualElement.textContent = `${Utilidades.formatearNumero(anguloActual, 1)}°`;
            anguloVisualElement.style.left = `${screenP2.x + 10}px`;
            anguloVisualElement.style.top = `${screenP2.y - 10}px`;
            anguloVisualElement.style.display = "block";
        }

        if (restriccionAngulo && ortoVisualElement) {
            ortoVisualElement.textContent = "Orto";
            ortoVisualElement.style.left = `${screenP2.x + 10}px`;
            ortoVisualElement.style.top = `${screenP2.y + 10}px`;
            ortoVisualElement.style.display = "block";
        } else if (ortoVisualElement) {
            ortoVisualElement.style.display = "none";
        }
    },

    ocultarIndicadoresVisuales() {
        if (distanciaVisualElement) distanciaVisualElement.style.display = "none";
        if (anguloVisualElement) anguloVisualElement.style.display = "none";
        if (ortoVisualElement) ortoVisualElement.style.display = "none";
        if (anguloInfoElement) anguloInfoElement.style.display = "none";
        if (lineInfoElement) lineInfoElement.textContent = "Longitud: 0 | Ángulo: 0°";
    },

    actualizarIndicadorOrigen() {
        if (!originIndicator2D || !originLabel2D || !canvas) return;
        const screenPos = Utilidades.canvasToScreen(0, 0);
        originIndicator2D.style.left = `${screenPos.x}px`;
        originIndicator2D.style.top = `${screenPos.y}px`;
        originIndicator2D.style.display = "block";
        originLabel2D.style.left = `${screenPos.x}px`;
        originLabel2D.style.top = `${screenPos.y - 20}px`;
        originLabel2D.style.display = "block";
        originLabel2D.textContent = "0,0";
    },

    actualizarInfoZoom() {
        console.log(`Zoom: ${zoomLevel.toFixed(2)}`);
    },

    guardarEstado() {
        if (!ctx) return;
        const estadoFormas = JSON.parse(JSON.stringify(formas));
        const estadoTransformacion = { zoom: zoomLevel, panX, panY };

        if (posicionHistorial < historialEstados.length - 1) {
            historialEstados = historialEstados.slice(0, posicionHistorial + 1);
        }

        historialEstados.push({
            formas: estadoFormas,
            transformacion: estadoTransformacion
        });

        if (historialEstados.length > Config.MAX_HISTORIAL) {
            historialEstados.shift();
        }

        posicionHistorial = historialEstados.length - 1;
        Controles.actualizarEstadoBotonDeshacer();
    },

    guardarEstadoParcial() {
        if (!ctx || !canvas) return;
        try {
            const currentTransform = ctx.getTransform();
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            this.tempCanvasState = ctx.getImageData(0, 0, canvas.width, canvas.height);
            ctx.setTransform(currentTransform);
        } catch (e) {
            console.error("Error guardando estado parcial:", e);
            this.tempCanvasState = null;
        }
    },

    restaurarEstado(indice) {
        if (!ctx || indice < 0 || indice >= historialEstados.length) return;
        const estado = historialEstados[indice];
        formas = JSON.parse(JSON.stringify(estado.formas));
        zoomLevel = estado.transformacion.zoom;
        panX = estado.transformacion.panX;
        panY = estado.transformacion.panY;
        this.aplicarTransformacion();
        this.redibujaTodo();
        Dibujo.actualizarSnapPuntos();
        Dibujo.actualizarTodasLasLineas3D();
        this.actualizarIndicadorOrigen(); // Añadido para mantener el indicador consistente
        this.actualizarInfoZoom();
        Controles.actualizarEstadoBotonDeshacer();
    },

    restaurarEstadoParcial() {
        if (!ctx || !canvas || !this.tempCanvasState) {
            this.redibujaTodo();
            return;
        }
        try {
            const currentTransform = ctx.getTransform();
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.putImageData(this.tempCanvasState, 0, 0);
            ctx.setTransform(currentTransform);
            this.redibujaTodo();
        } catch (e) {
            console.error("Error restaurando estado parcial:", e);
            this.redibujaTodo();
        }
    },

    limpiar() {
        formas = [];
        this.resetearVista();
        this.redibujaTodo();
        Dibujo.actualizarSnapPuntos();
        Dibujo.actualizarTodasLasLineas3D();
        this.guardarEstado();
        Utilidades.mostrarMensajeTemporalEstado("Lienzo 2D limpiado");
    },

    exportarSVG() {
        if (!canvas) return "";
        let svgString = `<svg width="${canvas.width}" height="${canvas.height}" xmlns="http://www.w3.org/2000/svg" style="background-color: ${Config.COLOR_FONDO_2D};">`;

        formas.forEach(forma => {
            const color = forma.color || Config.COLOR_LINEA_DEFAULT;
            const strokeWidth = 1.5;
            switch (forma.tipo) {
                case "linea":
                    svgString += `<line x1="${forma.x1}" y1="${forma.y1}" x2="${forma.x2}" y2="${forma.y2}" stroke="${color}" stroke-width="${strokeWidth}" />`;
                    break;
                case "rectangulo":
                    svgString += `<rect x="${forma.x}" y="${forma.y}" width="${forma.ancho}" height="${forma.alto}" stroke="${color}" stroke-width="${strokeWidth}" fill="none" />`;
                    break;
                case "circulo":
                    svgString += `<circle cx="${forma.x}" cy="${forma.y}" r="${forma.radio}" stroke="${color}" stroke-width="${strokeWidth}" fill="none" />`;
                    break;
                case "elipse":
                    svgString += `<ellipse cx="${forma.x}" cy="${forma.y}" rx="${forma.radiusX}" ry="${forma.radiusY}" stroke="${color}" stroke-width="${strokeWidth}" fill="none" />`;
                    break;
                case "polilinea":
                    if (forma.puntos && forma.puntos.length > 1) { // Añadido para soportar polilíneas en exportación SVG
                        for (let i = 0; i < forma.puntos.length - 1; i++) {
                            svgString += `<line x1="${forma.puntos[i].x}" y1="${forma.puntos[i].y}" x2="${forma.puntos[i + 1].x}" y2="${forma.puntos[i + 1].y}" stroke="${color}" stroke-width="${strokeWidth}" />`;
                        }
                    }
                    break;
                case "arco":
                    svgString += `<path d="M ${forma.x1} ${forma.y1} Q ${forma.cx} ${forma.cy} ${forma.x2} ${forma.y2}" stroke="${color}" stroke-width="${strokeWidth}" fill="none"/>`;
                    break;
            }
        });

        svgString += `</svg>`;

        const svgOutput = document.getElementById("svgOutput");
        if (svgOutput) {
            svgOutput.value = svgString;
            svgOutput.parentElement.style.display = "block";
        }
        return svgString;
    },

    importarSVG(svgString) {
        try {
            const parser = new DOMParser();
            const svgDoc = parser.parseFromString(svgString, "image/svg+xml");
            const svgElement = svgDoc.querySelector("svg");
            if (!svgElement) throw new Error("No se encontró elemento SVG raíz.");

            formas = [];

            svgElement.childNodes.forEach(node => {
                if (node.nodeType !== Node.ELEMENT_NODE) return;
                const tag = node.tagName.toLowerCase();
                const color = node.getAttribute("stroke") || Config.COLOR_LINEA_DEFAULT;
                let nuevaForma = null;

                try {
                    switch (tag) {
                        case "line":
                            nuevaForma = {
                                id: Utilidades.generarIdUnico(),
                                tipo: "linea",
                                color,
                                x1: parseFloat(node.getAttribute("x1")),
                                y1: parseFloat(node.getAttribute("y1")),
                                x2: parseFloat(node.getAttribute("x2")),
                                y2: parseFloat(node.getAttribute("y2"))
                            };
                            break;
                        case "rect":
                            nuevaForma = {
                                id: Utilidades.generarIdUnico(),
                                tipo: "rectangulo",
                                color,
                                x: parseFloat(node.getAttribute("x")),
                                y: parseFloat(node.getAttribute("y")),
                                ancho: parseFloat(node.getAttribute("width")),
                                alto: parseFloat(node.getAttribute("height"))
                            };
                            break;
                        case "circle":
                            nuevaForma = {
                                id: Utilidades.generarIdUnico(),
                                tipo: "circulo",
                                color,
                                x: parseFloat(node.getAttribute("cx")),
                                y: parseFloat(node.getAttribute("cy")),
                                radio: parseFloat(node.getAttribute("r"))
                            };
                            break;
                        case "ellipse":
                            nuevaForma = {
                                id: Utilidades.generarIdUnico(),
                                tipo: "elipse",
                                color,
                                x: parseFloat(node.getAttribute("cx")),
                                y: parseFloat(node.getAttribute("cy")),
                                radiusX: parseFloat(node.getAttribute("rx")),
                                radiusY: parseFloat(node.getAttribute("ry"))
                            };
                            break;
                        case "polyline":
                            const pointsAttr = node.getAttribute("points");
                            if (pointsAttr) {
                                const points = pointsAttr
                                    .trim()
                                    .split(/\s+/)
                                    .map(pair => {
                                        const coords = pair.split(",");
                                        return { x: parseFloat(coords[0]), y: parseFloat(coords[1]) };
                                    })
                                    .filter(p => !isNaN(p.x) && !isNaN(p.y));
                                if (points.length > 1) {
                                    nuevaForma = { // Guardar como polilínea en lugar de líneas individuales
                                        id: Utilidades.generarIdUnico(),
                                        tipo: "polilinea",
                                        color,
                                        puntos: points
                                    };
                                }
                            }
                            break;
                        case "path":
                            console.warn("Importación de <path> limitada a arcos cuadráticos.");
                            const dAttr = node.getAttribute("d");
                            const match = dAttr && dAttr.match(/M\s*([\d.-]+)\s*([\d.-]+)\s*Q\s*([\d.-]+)\s*([\d.-]+)\s*([\d.-]+)\s*([\d.-]+)/i);
                            if (match) {
                                nuevaForma = {
                                    id: Utilidades.generarIdUnico(),
                                    tipo: "arco",
                                    color,
                                    x1: parseFloat(match[1]),
                                    y1: parseFloat(match[2]),
                                    cx: parseFloat(match[3]),
                                    cy: parseFloat(match[4]),
                                    x2: parseFloat(match[5]),
                                    y2: parseFloat(match[6])
                                };
                            }
                            break;
                    }
                } catch (parseError) {
                    console.warn(`Error parseando elemento SVG <${tag}>:`, parseError, node);
                }

                if (nuevaForma && Object.keys(nuevaForma).every(key => {
                    if (["id", "tipo", "color", "puntos"].includes(key)) return true;
                    return !isNaN(nuevaForma[key]) && nuevaForma[key] !== null;
                })) {
                    formas.push(nuevaForma);
                }
            });

            this.redibujaTodo();
            Dibujo.actualizarSnapPuntos();
            Dibujo.actualizarTodasLasLineas3D();
            this.guardarEstado();
            Utilidades.mostrarMensajeTemporalEstado("SVG importado correctamente");
        } catch (error) {
            console.error("Error al importar SVG:", error);
            Utilidades.mostrarMensajeTemporalEstado(`Error al importar SVG: ${error.message}`);
            this.redibujaTodo();
        }
    },

    limpiarEventos() {
        if (!canvas) return;
        if (this.panEventListeners) {
            canvas.removeEventListener("mousedown", this.panEventListeners.mousedown);
            canvas.removeEventListener("mousemove", this.panEventListeners.mousemove);
            canvas.removeEventListener("mouseup", this.panEventListeners.mouseup);
            canvas.removeEventListener("mouseleave", this.panEventListeners.mouseleave);
            canvas.removeEventListener("contextmenu", this.panEventListeners.contextmenu);
            this.panEventListeners = null;
        }
        if (this.zoomEventListeners) {
            canvas.removeEventListener("wheel", this.zoomEventListeners.wheel);
            this.zoomEventListeners = null;
        }
    }
};

    // =========================================================================
/// =========================================================================
// Módulo de Escena 3D (Manejo de Three.js)
// =========================================================================
const Escena3D = {
    // Encapsulamos las variables dentro del objeto para evitar conflictos globales
    scene: null,
    camera: null,
    renderer: null,
    controls: null,
    gridHelper3D: null,
    plane3D: null,
    tempLine3D: null,
    startPoint3D: null,
    isDrawing3D: false,
    container3D: null,
    escena3DInitializada: false,
    animationFrameId: null,

    inicializar() {
        this.container3D = document.getElementById("container3D");
        if (!this.container3D) {
            console.error("Contenedor 3D no encontrado.");
            Utilidades.mostrarMensajeTemporalEstado("Error: Contenedor 3D no encontrado.", 5000);
            return false;
        }

        // Limpiar cualquier renderizador previo
        while (this.container3D.firstChild) {
            this.container3D.removeChild(this.container3D.firstChild);
        }

        try {
            console.log("Inicializando Three.js...");
            if (typeof THREE === "undefined") {
                throw new Error("Three.js no está cargado.");
            }
            if (typeof THREE.OrbitControls === "undefined") {
                throw new Error("OrbitControls no está cargado.");
            }

            // Escena
            this.scene = new THREE.Scene();
            this.scene.background = new THREE.Color(0x111111);

            // Cámara
            const width = this.container3D.clientWidth || 1;
            const height = this.container3D.clientHeight || 1;
            this.camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 2000);
            this.camera.position.set(0, 150, 400);
            this.camera.lookAt(0, 0, 0);

            // Renderizador
            this.renderer = new THREE.WebGLRenderer({ antialias: true });
            this.renderer.setSize(width, height);
            this.container3D.appendChild(this.renderer.domElement);

            // Controles
            this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
            this.controls.enableDamping = true;
            this.controls.dampingFactor = 0.1;
            this.controls.screenSpacePanning = false;
            this.controls.target.set(0, 0, 0);
            this.controls.maxPolarAngle = Math.PI / 2;
            this.controls.minDistance = 50;
            this.controls.maxDistance = 1000;

            // Luces
            const ambientLight = new THREE.AmbientLight(0x404040, 2);
            this.scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
            directionalLight.position.set(50, 100, 75);
            this.scene.add(directionalLight);

            // Rejilla
            this.gridHelper3D = new THREE.GridHelper(
                Config.TAMANO_REJILLA_3D,
                Config.DIVISIONES_REJILLA_3D,
                Config.COLOR_CENTRO_3D,
                Config.COLOR_REJILLA_3D
            );
            this.scene.add(this.gridHelper3D);

            // Plano invisible para raycasting
            const planeGeometry = new THREE.PlaneGeometry(Config.TAMANO_REJILLA_3D, Config.TAMANO_REJILLA_3D);
            const planeMaterial = new THREE.MeshBasicMaterial({ visible: false, side: THREE.DoubleSide });
            this.plane3D = new THREE.Mesh(planeGeometry, planeMaterial);
            this.plane3D.rotation.x = -Math.PI / 2;
            this.scene.add(this.plane3D);

            // Ejes
            const axesHelper = new THREE.AxesHelper(100);
            this.scene.add(axesHelper);

            // Eventos
            this.inicializarEventos3D();

            // Iniciar animación
            this.animar();

            // Evento de resize
            this.handleResize = () => this.onWindowResize();
            window.addEventListener("resize", this.handleResize, false);

            this.escena3DInitializada = true;
            console.log("Escena 3D inicializada.");
            this.container3D.setAttribute("aria-label", "Vista 3D activa para dibujo CAD.");
            return true;
        } catch (error) {
            console.error("Error inicializando Three.js:", error);
            Utilidades.mostrarMensajeTemporalEstado(`Error al iniciar 3D: ${error.message}`, 5000);
            return false;
        }
    },

    inicializarEventos3D() {
        if (!this.container3D) {
            console.error("Contenedor 3D no disponible para eventos.");
            Utilidades.mostrarMensajeTemporalEstado("Error: Contenedor 3D no disponible.", 5000);
            return;
        }
        console.log("Registrando eventos 3D...");

        // Definir manejadores
        this.handlePointerDown = (event) => this.onPointerDown(event);
        this.handlePointerMove = (event) => this.onPointerMove(event);
        this.handlePointerUp = (event) => this.onPointerUp(event);
        this.handleContextMenu = (event) => event.preventDefault();

        // Limpiar eventos previos
        this.limpiarEventos3D();

        // Registrar nuevos eventos
        this.container3D.addEventListener("pointerdown", this.handlePointerDown);
        this.container3D.addEventListener("pointermove", this.handlePointerMove);
        this.container3D.addEventListener("pointerup", this.handlePointerUp);
        this.container3D.addEventListener("contextmenu", this.handleContextMenu);
    },

    limpiarEventos3D() {
        if (!this.container3D) return;
        if (this.handlePointerDown) {
            this.container3D.removeEventListener("pointerdown", this.handlePointerDown);
        }
        if (this.handlePointerMove) {
            this.container3D.removeEventListener("pointermove", this.handlePointerMove);
        }
        if (this.handlePointerUp) {
            this.container3D.removeEventListener("pointerup", this.handlePointerUp);
        }
        if (this.handleContextMenu) {
            this.container3D.removeEventListener("contextmenu", this.handleContextMenu);
        }
        this.handlePointerDown = null;
        this.handlePointerMove = null;
        this.handlePointerUp = null;
        this.handleContextMenu = null;
    },

    onPointerDown(event) {
        if (!this.scene || !this.camera || !this.plane3D) return;
        event.preventDefault();

        const rect = this.container3D.getBoundingClientRect();
        const mouse = new THREE.Vector2(
            ((event.clientX - rect.left) / rect.width) * 2 - 1,
            -((event.clientY - rect.top) / rect.height) * 2 + 1
        );
        const raycaster = new THREE.Raycaster();
        raycaster.setFromCamera(mouse, this.camera);
        const intersects = raycaster.intersectObject(this.plane3D);
        if (intersects.length === 0) return;

        const point = intersects[0].point;
        const finalX = point.x;
        const finalZ = point.z;

        console.log("Clic 3D en:", finalX, finalZ);

        if (["linea", "polilinea", "rectangulo", "circulo", "elipse"].includes(modoActual)) {
            if (!this.isDrawing3D) {
                this.startPoint3D = new THREE.Vector3(finalX, 0, finalZ);
                this.isDrawing3D = true;
                this.container3D.classList.add("drawing");
                Dibujo.iniciarDibujo(finalX, finalZ, false);
            }
        }
    },

    onPointerMove(event) {
        if (!this.scene || !this.camera || !this.plane3D || !this.isDrawing3D) return;
        event.preventDefault();

        const rect = this.container3D.getBoundingClientRect();
        const mouse = new THREE.Vector2(
            ((event.clientX - rect.left) / rect.width) * 2 - 1,
            -((event.clientY - rect.top) / rect.height) * 2 + 1
        );
        const raycaster = new THREE.Raycaster();
        raycaster.setFromCamera(mouse, this.camera);
        const intersects = raycaster.intersectObject(this.plane3D);
        if (intersects.length === 0) return;

        const point = intersects[0].point;
        let finalX = point.x;
        let finalZ = point.z;

        // Aplicar restricción de ángulo si está activa
        if (restriccionAngulo && this.startPoint3D) {
            const restricted = Utilidades.restringirAngulo(this.startPoint3D.x, this.startPoint3D.z, finalX, finalZ);
            finalX = restricted.x;
            finalZ = restricted.y;
        }

        // Actualizar línea temporal
        if (this.startPoint3D) {
            if (this.tempLine3D) {
                this.scene.remove(this.tempLine3D);
                this.tempLine3D.geometry.dispose();
                this.tempLine3D.material.dispose();
            }
            const geometry = new THREE.BufferGeometry();
            const points = [
                this.startPoint3D,
                new THREE.Vector3(finalX, 0, finalZ)
            ];
            geometry.setFromPoints(points);
            const material = new THREE.LineBasicMaterial({ color: Config.COLOR_LINEA_TEMP_3D || 0xffff00 });
            this.tempLine3D = new THREE.Line(geometry, material);
            this.scene.add(this.tempLine3D);
        }
    },

    onPointerUp(event) {
        if (!this.scene || !this.camera || !this.plane3D || !this.isDrawing3D) return;
        event.preventDefault();

        const rect = this.container3D.getBoundingClientRect();
        const mouse = new THREE.Vector2(
            ((event.clientX - rect.left) / rect.width) * 2 - 1,
            -((event.clientY - rect.top) / rect.height) * 2 + 1
        );
        const raycaster = new THREE.Raycaster();
        raycaster.setFromCamera(mouse, this.camera);
        const intersects = raycaster.intersectObject(this.plane3D);
        if (intersects.length === 0) return;

        const point = intersects[0].point;
        let finalX = point.x;
        let finalZ = point.z;

        // Aplicar restricción de ángulo si está activa
        if (restriccionAngulo && this.startPoint3D) {
            const restricted = Utilidades.restringirAngulo(this.startPoint3D.x, this.startPoint3D.z, finalX, finalZ);
            finalX = restricted.x;
            finalZ = restricted.y;
        }

        Dibujo.finalizarDibujoEn(finalX, finalZ);
        if (this.tempLine3D) {
            this.scene.remove(this.tempLine3D);
            this.tempLine3D.geometry.dispose();
            this.tempLine3D.material.dispose();
            this.tempLine3D = null;
        }

        if (modoActual !== "polilinea") {
            this.isDrawing3D = false;
            this.startPoint3D = null;
            this.container3D.classList.remove("drawing");
        } else {
            this.startPoint3D = new THREE.Vector3(finalX, 0, finalZ);
        }
    },

    toggleVista(visible) {
        if (!this.container3D) {
            this.container3D = document.getElementById("container3D");
            if (!this.container3D) {
                console.error("Contenedor 3D no encontrado.");
                Utilidades.mostrarMensajeTemporalEstado("Error: Contenedor 3D no encontrado.", 5000);
                return;
            }
        }
        const btnToggle3D = document.getElementById("btnToggle3D");
        if (visible) {
            this.container3D.style.display = "block";
            if (btnToggle3D) {
                btnToggle3D.textContent = "Desactivar 3D";
                btnToggle3D.classList.add("active");
                btnToggle3D.setAttribute("aria-pressed", "true");
            }
            if (!this.escena3DInitializada) {
                if (this.inicializar()) {
                    Dibujo.actualizarTodasLasLineas3D();
                }
            } else {
                this.onWindowResize();
                Dibujo.actualizarTodasLasLineas3D();
            }
        } else {
            this.container3D.style.display = "none";
            if (btnToggle3D) {
                btnToggle3D.textContent = "Activar 3D";
                btnToggle3D.classList.remove("active");
                btnToggle3D.setAttribute("aria-pressed", "false");
            }
            if (this.isDrawing3D) {
                this.cancelarDibujo3D();
            }
            if (this.escena3DInitializada) {
                this.limpiarRecursos();
                this.escena3DInitializada = false;
            }
        }
        this.container3D.setAttribute("aria-hidden", visible ? "false" : "true");
    },

    cancelarDibujo3D() {
        this.isDrawing3D = false;
        this.startPoint3D = null;
        if (this.tempLine3D) {
            this.scene.remove(this.tempLine3D);
            this.tempLine3D.geometry.dispose();
            this.tempLine3D.material.dispose();
            this.tempLine3D = null;
        }
        this.container3D.classList.remove("drawing");
        // Reiniciar estado de dibujo
        puntoInicial = null;
        dibujando = false;
        Canvas2D.dibujar();
        Utilidades.mostrarMensajeTemporalEstado("Dibujo 3D cancelado.", 1500);
    },

    limpiarRecursos() {
        if (this.animationFrameId) {
            cancelAnimationFrame(this.animationFrameId);
            this.animationFrameId = null;
        }
        if (this.handleResize) {
            window.removeEventListener("resize", this.handleResize);
            this.handleResize = null;
        }
        this.limpiarEventos3D();
        if (this.controls) {
            this.controls.dispose();
            this.controls = null;
        }
        if (this.renderer) {
            this.renderer.dispose();
            if (this.renderer.domElement && this.container3D) {
                this.container3D.removeChild(this.renderer.domElement);
            }
            this.renderer = null;
        }
        if (this.scene) {
            this.scene.traverse((object) => {
                if (object.geometry) object.geometry.dispose();
                if (object.material) {
                    if (Array.isArray(object.material)) {
                        object.material.forEach(material => material.dispose());
                    } else {
                        object.material.dispose();
                    }
                }
            });
            this.scene.clear();
            this.scene = null;
        }
        this.camera = null;
        this.gridHelper3D = null;
        this.plane3D = null;
        this.tempLine3D = null;
        this.startPoint3D = null;
        this.isDrawing3D = false;
        console.log("Recursos 3D limpiados.");
    },

    animar() {
        this.animationFrameId = requestAnimationFrame(() => this.animar());
        if (this.controls) this.controls.update();
        if (this.renderer && this.scene && this.camera) {
            this.renderer.render(this.scene, this.camera);
        }
    },

    resetear() {
        if (this.camera && this.controls && this.scene) {
            this.camera.position.set(0, 150, 400);
            this.controls.target.set(0, 0, 0);
            this.controls.update();
            Utilidades.mostrarMensajeTemporalEstado("Vista 3D reiniciada", 1500);
            this.container3D.setAttribute("aria-label", "Vista 3D reiniciada para dibujo CAD.");
        }
    },

    onWindowResize() {
        if (!this.camera || !this.renderer || !this.container3D) return;
        const width = this.container3D.clientWidth || 1;
        const height = this.container3D.clientHeight || 1;
        this.camera.aspect = width / height;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(width, height);
    },

    actualizarLinea3D(forma) {
        if (!this.scene || !this.escena3DInitializada) return;

        // Eliminar línea existente si ya está en la escena
        const existingLine = this.scene.getObjectByName(`linea_${forma.id}`);
        if (existingLine) {
            this.scene.remove(existingLine);
            existingLine.geometry.dispose();
            existingLine.material.dispose();
        }

        // Crear nueva línea en 3D
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array([
            forma.x1, 0, forma.y1, // Punto inicial
            forma.x2, 0, forma.y2   // Punto final
        ]);
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        const material = new THREE.LineBasicMaterial({ color: forma.color });
        const line = new THREE.Line(geometry, material);
        line.name = `linea_${forma.id}`;
        this.scene.add(line);
    },

    handleMouseMove3D(x, y) {
        // Placeholder para interacción en 3D (usado por Controles, pero no necesario ahora)
    },

    handleMouseDown3D(x, y) {
        // Placeholder para interacción en 3D (usado por Controles, pero no necesario ahora)
    },

    handleMouseUp3D() {
        // Placeholder para interacción en 3D (usado por Controles, pero no necesario ahora)
    },
};

// =========================================================================
// =========================================================================
// Módulo de Controles UI (Manejo de botones y eventos principales)
// controles.js
const Controles = {
    inicializar() {
        // Obtener el canvas y otros elementos del DOM
        canvas = document.getElementById("lienzo");
        if (!canvas) {
            console.error("Canvas no encontrado.");
            Utilidades.mostrarMensajeTemporalEstado("Error: Canvas no encontrado.", 5000);
            return;
        }

        // Inicializar elementos UI
        coordsElement = document.getElementById("coordCanvas");
        snapInfoElement = document.getElementById("snapInfo");
        lineInfoElement = document.getElementById("lineInfo");
        entradaDimensionesElement = document.getElementById("entradaDimensiones");
        inputDistanciaElement = document.getElementById("inputDistancia");
        inputXElement = document.getElementById("inputX");
        inputYElement = document.getElementById("inputY");
        distanciaVisualElement = document.getElementById("distanciaVisual");
        anguloVisualElement = document.getElementById("anguloVisual");
        ortoVisualElement = document.getElementById("ortoVisual");
        anguloInfoElement = document.getElementById("anguloInfoElement");
        originIndicator2D = document.getElementById("originIndicator2D");
        originLabel2D = document.getElementById("originLabel2D");

        // Registrar eventos para los botones y otros elementos
        this.inicializarBotonesHerramientas();
        this.inicializarBotonesModo();
        this.inicializarBotonesAccion();
        this.inicializarEventosCanvas();
        this.inicializarEventosTeclado();
        this.inicializarCoordenadasPrecisas();
        this.inicializarSnapConfig();
        this.inicializarModales();
        this.actualizarEstadoBotonDeshacer();

        // Asegurarse de que el canvas tenga el foco inicial
        canvas.focus();
    },

    inicializarBotonesHerramientas() {
        const herramientas = {
            btnLinea: "linea",
            btnPolilinea: "polilinea",
            btnRectangulo: "rectangulo",
            btnCirculo: "circulo",
            btnElipse: "elipse"
            // btnArco: "arco", // Desactivado hasta implementar
            // btnMano: "mano"  // Desactivado hasta implementar
        };
        Object.entries(herramientas).forEach(([id, modo]) => {
            Utilidades.registrarEventos(id, {
                click: () => this.seleccionarModo(modo, id)
            });
        });
        this.activarBoton("btnLinea");
    },

    inicializarBotonesModo() {
        Utilidades.registrarEventos("btnDimension", {
            click: () => {
                const btn = document.getElementById("btnDimension");
                if (!btn) return;
                if (puntoInicial) {
                    Dibujo.activarDimensionManual();
                    btn.classList.add("active");
                    btn.setAttribute("aria-pressed", "true");
                } else {
                    Utilidades.mostrarMensajeTemporalEstado("Defina primero el punto inicial");
                    dimensionManualActiva = false;
                    btn.classList.remove("active");
                    btn.setAttribute("aria-pressed", "false");
                    if (entradaDimensionesElement) entradaDimensionesElement.style.display = "none";
                }
            }
        });
        Utilidades.registrarEventos("btnAplicarDimensiones", { click: () => Dibujo.aplicarDimensionManual() });
        if (inputDistanciaElement) {
            inputDistanciaElement.addEventListener("keypress", (e) => {
                if (e.key === "Enter") Dibujo.aplicarDimensionManual();
            });
        }

        Utilidades.registrarEventos("btnRestriccion", { click: () => this.toggleRestriccionAngulo() });
        Utilidades.registrarEventos("btnSnap", { click: (e) => this.toggleMenuSnap(e) });
        Utilidades.registrarEventos("btnRejilla", { click: () => this.toggleRejilla() });
        Utilidades.registrarEventos("btnSnapGrid", { click: () => this.toggleSnapGrid() });
    },

    inicializarBotonesAccion() {
        Utilidades.registrarEventos("btnDeshacer", { click: () => this.deshacer() });
        Utilidades.registrarEventos("btnRehacer", { click: () => this.rehacer() });
        Utilidades.registrarEventos("btnLimpiar", { click: () => Canvas2D.limpiar() });
        Utilidades.registrarEventos("btnGuardarSVG", { click: () => Canvas2D.exportarSVG() });
        Utilidades.registrarEventos("btnImportarSVG", { click: () => this.abrirModal("modalImportarSVG") });
        Utilidades.registrarEventos("btnAtajos", { click: () => this.abrirModal("modalAtajos") });
        Utilidades.registrarEventos("btnToggle3D", {
            click: () => {
                if (!container3D) {
                    console.error("Contenedor 3D no encontrado.");
                    Utilidades.mostrarMensajeTemporalEstado("Error: Contenedor 3D no encontrado.", 5000);
                    return;
                }
                Escena3D.toggleVista(container3D.style.display === "none");
            }
        });
        Utilidades.registrarEventos("btnReiniciarVista3D", { click: () => Escena3D.resetear() });
        Utilidades.registrarEventos("btnCentrarVistas", {
            click: () => {
                Canvas2D.resetearVista();
                if (escena3DInitializada) Escena3D.resetear();
                Utilidades.mostrarMensajeTemporalEstado("Vistas centradas");
            }
        });

        // Zoom controls
        Utilidades.registrarEventos("zoomIn", { click: () => Canvas2D.zoom(1 + Config.ZOOM_SPEED) });
        Utilidades.registrarEventos("zoomOut", { click: () => Canvas2D.zoom(1 - Config.ZOOM_SPEED) });
        Utilidades.registrarEventos("zoomFit", { click: () => Canvas2D.zoomFit() });
    },

    inicializarEventosCanvas() {
        this.limpiarEventosCanvas();

        this.handleMouseMove = (e) => {
            const { x, y } = Utilidades.screenToCanvas(e.clientX, e.clientY);
            if (isDrawing3D) {
                Escena3D.handleMouseMove3D(x, y);
            }
            xAnterior = x;
            yAnterior = y;

            // Actualizar coordenadas en la UI
            const coordsTexto = `X: ${Utilidades.formatearNumero(x)} Y: ${Utilidades.formatearNumero(y)}`;
            if (coordsElement) coordsElement.textContent = coordsTexto;
            if (inputXElement) inputXElement.value = Utilidades.formatearNumero(x);
            if (inputYElement) inputYElement.value = Utilidades.formatearNumero(y);

            Canvas2D.dibujar();
        };

        this.handleMouseDown = (e) => {
            const { x, y } = Utilidades.screenToCanvas(e.clientX, e.clientY);
            const timestamp = Date.now();
            const dobleClic = timestamp - ultimoClickTimestamp < 300;
            ultimoClickTimestamp = timestamp;

            if (e.button === 1 || (e.button === 0 && e.ctrlKey)) {
                isPanning = true;
                startPanX = e.clientX - panX * zoomLevel;
                startPanY = e.clientY - panY * zoomLevel;
                return;
            }

            if (isDrawing3D) {
                Escena3D.handleMouseDown3D(x, y);
                return;
            }

            if (!dibujando) {
                Dibujo.iniciarDibujo(x, y, dobleClic);
            } else {
                Dibujo.finalizarDibujoEn(x, y);
            }
        };

        this.handleMouseUp = (e) => {
            isPanning = false;
            if (isDrawing3D) {
                Escena3D.handleMouseUp3D();
            }
        };

        this.handleWheel = (e) => {
            e.preventDefault();
            const delta = e.deltaY < 0 ? 1 : -1;
            const zoomAnterior = zoomLevel;
            zoomLevel = Math.min(Math.max(zoomLevel + delta * Config.ZOOM_SPEED * zoomLevel, Config.MIN_ZOOM), Config.MAX_ZOOM);

            const rect = canvas.getBoundingClientRect();
            const mouseX = (e.clientX - rect.left) / zoomAnterior;
            const mouseY = (e.clientY - rect.top) / zoomAnterior;

            panX -= mouseX * (zoomLevel - zoomAnterior);
            panY -= mouseY * (zoomLevel - zoomAnterior);

            Utilidades.actualizarInfoCoordenadas(mouseX + panX, mouseY + panY);
            Canvas2D.dibujar();
        };

        this.handleKeyDown = (e) => {
            const targetTag = e.target.tagName.toLowerCase();
            if (targetTag === "input" || targetTag === "textarea") {
                if (e.key === "Enter" && (e.target === inputXElement || e.target === inputYElement)) {
                    this.manejarEnterCoordenadas();
                } else if (e.key === "Enter" && e.target === inputDistanciaElement) {
                    Dibujo.aplicarDimensionManual();
                } else if (e.key === "Escape") {
                    e.target.blur();
                    this.cancelarOperacionActual();
                }
                return;
            }

            switch (e.key.toUpperCase()) {
                case "ESCAPE":
                    this.cancelarOperacionActual();
                    this.cerrarMenuSnapSiAbierto();
                    this.cerrarModalesAbiertos();
                    break;
                case "L": this.seleccionarModo("linea", "btnLinea"); break;
                case "P": this.seleccionarModo("polilinea", "btnPolilinea"); break;
                case "R": this.seleccionarModo("rectangulo", "btnRectangulo"); break;
                case "C": this.seleccionarModo("circulo", "btnCirculo"); break;
                case "E": this.seleccionarModo("elipse", "btnElipse"); break;
                case "F3": e.preventDefault(); this.toggleSnap(); break;
                case "F7": e.preventDefault(); this.toggleRejilla(); break;
                case "F8": e.preventDefault(); this.toggleRestriccionAngulo(); break;
                case "F9": e.preventDefault(); this.toggleSnapGrid(); break;
                case "Z":
                    if (e.ctrlKey || e.metaKey) {
                        e.preventDefault();
                        if (e.shiftKey) {
                            this.rehacer();
                        } else {
                            this.deshacer();
                        }
                    }
                    break;
            }
        };

        this.handleKeyUp = (e) => {
            // Manejo de teclas (sin cambios por ahora)
        };

        this.handleFocus = () => {
            // Manejo de foco (sin cambios por ahora)
        };

        this.handleBlur = () => {
            // Manejo de desenfoque (sin cambios por ahora)
        };

        canvas.addEventListener("mousemove", this.handleMouseMove);
        canvas.addEventListener("mousedown", this.handleMouseDown);
        canvas.addEventListener("mouseup", this.handleMouseUp);
        canvas.addEventListener("wheel", this.handleWheel);
        canvas.addEventListener("keydown", this.handleKeyDown);
        canvas.addEventListener("keyup", this.handleKeyUp);
        canvas.addEventListener("focus", this.handleFocus);
        canvas.addEventListener("blur", this.handleBlur);
    },

    limpiarEventosCanvas() {
        if (!canvas) return;
        if (this.handleMouseMove) canvas.removeEventListener("mousemove", this.handleMouseMove);
        if (this.handleMouseDown) canvas.removeEventListener("mousedown", this.handleMouseDown);
        if (this.handleMouseUp) canvas.removeEventListener("mouseup", this.handleMouseUp);
        if (this.handleWheel) canvas.removeEventListener("wheel", this.handleWheel);
        if (this.handleKeyDown) canvas.removeEventListener("keydown", this.handleKeyDown);
        if (this.handleKeyUp) canvas.removeEventListener("keyup", this.handleKeyUp);
        if (this.handleFocus) canvas.removeEventListener("focus", this.handleFocus);
        if (this.handleBlur) canvas.removeEventListener("blur", this.handleBlur);
        this.handleMouseMove = null;
        this.handleMouseDown = null;
        this.handleMouseUp = null;
        this.handleWheel = null;
        this.handleKeyDown = null;
        this.handleKeyUp = null;
        this.handleFocus = null;
        this.handleBlur = null;
    },

    inicializarEventosTeclado() {
        if (this.handleKeyDown) {
            document.removeEventListener("keydown", this.handleKeyDown);
        }

        this.handleKeyDown = (e) => {
            const targetTag = e.target.tagName.toLowerCase();
            if (targetTag === "input" || targetTag === "textarea") {
                if (e.key === "Enter" && (e.target === inputXElement || e.target === inputYElement)) {
                    this.manejarEnterCoordenadas();
                } else if (e.key === "Enter" && e.target === inputDistanciaElement) {
                    Dibujo.aplicarDimensionManual();
                } else if (e.key === "Escape") {
                    e.target.blur();
                    this.cancelarOperacionActual();
                }
                return;
            }

            switch (e.key.toUpperCase()) {
                case "ESCAPE":
                    this.cancelarOperacionActual();
                    this.cerrarMenuSnapSiAbierto();
                    this.cerrarModalesAbiertos();
                    break;
                case "L": this.seleccionarModo("linea", "btnLinea"); break;
                case "P": this.seleccionarModo("polilinea", "btnPolilinea"); break;
                case "R": this.seleccionarModo("rectangulo", "btnRectangulo"); break;
                case "C": this.seleccionarModo("circulo", "btnCirculo"); break;
                case "E": this.seleccionarModo("elipse", "btnElipse"); break;
                case "F3": e.preventDefault(); this.toggleSnap(); break;
                case "F7": e.preventDefault(); this.toggleRejilla(); break;
                case "F8": e.preventDefault(); this.toggleRestriccionAngulo(); break;
                case "F9": e.preventDefault(); this.toggleSnapGrid(); break;
                case "Z":
                    if (e.ctrlKey || e.metaKey) {
                        e.preventDefault();
                        if (e.shiftKey) {
                            this.rehacer();
                        } else {
                            this.deshacer();
                        }
                    }
                    break;
            }
        };

        document.addEventListener("keydown", this.handleKeyDown);
    },

    inicializarCoordenadasPrecisas() {
        if (inputXElement) {
            inputXElement.addEventListener("change", this.actualizarPreviewDesdeInput.bind(this));
            inputXElement.addEventListener("keypress", (e) => {
                if (e.key === "Enter") inputYElement?.focus();
            });
        }
        if (inputYElement) {
            inputYElement.addEventListener("change", this.actualizarPreviewDesdeInput.bind(this));
            inputYElement.addEventListener("keypress", (e) => {
                if (e.key === "Enter") this.manejarEnterCoordenadas();
            });
        }
    },

    actualizarPreviewDesdeInput() {
        if (puntoInicial && !dimensionManualActiva) {
            const x = parseFloat(inputXElement.value);
            const y = parseFloat(inputYElement.value);
            if (!isNaN(x) && !isNaN(y)) {
                Canvas2D.dibujar();
            }
        }
    },

    manejarEnterCoordenadas() {
        const x = parseFloat(inputXElement.value);
        const y = parseFloat(inputYElement.value);
        if (!isNaN(x) && !isNaN(y)) {
            if (!dibujando) {
                Dibujo.iniciarDibujo(x, y, false);
            } else {
                Dibujo.finalizarDibujoEn(x, y);
            }
            Canvas2D.dibujar();
            canvas.focus();
        } else {
            Utilidades.mostrarMensajeTemporalEstado("Coordenadas inválidas");
        }
    },

    seleccionarModo(modo, btnId) {
        modoActual = modo;
        this.activarBoton(btnId);
        Utilidades.mostrarMensajeTemporalEstado(`Modo ${modo} activado`);
        if (puntoInicial) {
            Dibujo.cancelarDibujo();
        }
    },

    activarBoton(btnId) {
        const botones = ["btnLinea", "btnPolilinea", "btnRectangulo", "btnCirculo", "btnElipse"];
        botones.forEach(id => {
            const btn = document.getElementById(id);
            if (btn) {
                if (id === btnId) {
                    btn.classList.add("active");
                    btn.setAttribute("aria-pressed", "true");
                } else {
                    btn.classList.remove("active");
                    btn.setAttribute("aria-pressed", "false");
                }
            }
        });
    },

    toggleRestriccionAngulo() {
        restriccionAngulo = !restriccionAngulo;
        const btn = document.getElementById("btnRestriccion");
        if (btn) {
            btn.textContent = `Orto (${restriccionAngulo ? "ON" : "OFF"})`;
            btn.classList.toggle("active", restriccionAngulo);
            btn.setAttribute("aria-pressed", restriccionAngulo.toString());
        }
        if (ortoVisualElement) {
            ortoVisualElement.textContent = `Orto: ${restriccionAngulo ? "ON" : "OFF"}`;
            ortoVisualElement.style.display = restriccionAngulo ? "block" : "none";
            const screenPos = Utilidades.canvasToScreen(0, 0);
            ortoVisualElement.style.left = `${screenPos.x + 50}px`;
            ortoVisualElement.style.top = `${screenPos.y + 50}px`;
        }
        Utilidades.mostrarMensajeTemporalEstado(`Restricción de ángulo ${restriccionAngulo ? "activada" : "desactivada"}`);
    },

    toggleSnap() {
        snapActivo = !snapActivo;
        const btn = document.getElementById("btnSnap");
        if (btn) {
            btn.textContent = `Snap (${snapActivo ? "ON" : "OFF"})`;
            btn.classList.toggle("active", snapActivo);
            btn.setAttribute("aria-pressed", snapActivo.toString());
        }
        Utilidades.mostrarMensajeTemporalEstado(`Snap ${snapActivo ? "activado" : "desactivado"}`);
    },

    toggleRejilla() {
        rejillaActiva = !rejillaActiva;
        Canvas2D.redibujaTodo();
        const btn = document.getElementById("btnRejilla");
        if (btn) {
            btn.textContent = `Rejilla (${rejillaActiva ? "ON" : "OFF"})`;
            btn.classList.toggle("active", rejillaActiva);
            btn.setAttribute("aria-pressed", rejillaActiva.toString());
        }
        Utilidades.mostrarMensajeTemporalEstado(`Rejilla ${rejillaActiva ? "activada" : "desactivada"}`);
    },

    toggleSnapGrid() {
        snapToGridActivo = !snapToGridActivo;
        const btn = document.getElementById("btnSnapGrid");
        if (btn) {
            btn.textContent = `Snap Rejilla (${snapToGridActivo ? "ON" : "OFF"})`;
            btn.classList.toggle("active", snapToGridActivo);
            btn.setAttribute("aria-pressed", snapToGridActivo.toString());
        }
        Utilidades.mostrarMensajeTemporalEstado(`Snap a rejilla ${snapToGridActivo ? "activado" : "desactivado"}`);
    },

    toggleMenuSnap(e) {
        const menu = document.getElementById("menuSnapObjetos");
        const btn = e.target;
        if (menu.style.display === "block") {
            menu.style.display = "none";
            btn.setAttribute("aria-expanded", "false");
        } else {
            const rect = btn.getBoundingClientRect();
            menu.style.left = `${rect.left}px`;
            menu.style.top = `${rect.bottom + 5}px`;
            menu.style.display = "block";
            btn.setAttribute("aria-expanded", "true");
        }
    },

    cerrarMenuSnapSiAbierto() {
        const menu = document.getElementById("menuSnapObjetos");
        const btn = document.getElementById("btnSnap");
        if (menu && menu.style.display === "block") {
            menu.style.display = "none";
            if (btn) btn.setAttribute("aria-expanded", "false");
        }
    },

    inicializarSnapConfig() {
        const snapOptions = document.querySelectorAll("#menuSnapObjetos input[type='checkbox']");
        snapOptions.forEach(option => {
            const tipo = option.id.replace("snap", "").toLowerCase();
            option.checked = tiposSnap[tipo];
            option.addEventListener("change", () => {
                tiposSnap[tipo] = option.checked;
                option.setAttribute("aria-checked", option.checked.toString());
                Dibujo.actualizarSnapPuntos();
                Utilidades.mostrarMensajeTemporalEstado(`Snap ${tipo} ${option.checked ? "activado" : "desactivado"}`);
            });
        });
    },

    inicializarModales() {
        // Manejo de modales genéricos
        document.querySelectorAll(".modal").forEach(modal => {
            const closeBtn = modal.querySelector(".close-btn");
            if (closeBtn) {
                closeBtn.addEventListener("click", () => {
                    modal.style.display = "none";
                    modal.setAttribute("aria-hidden", "true");
                });
            }
            modal.addEventListener("click", (e) => {
                if (e.target === modal) {
                    modal.style.display = "none";
                    modal.setAttribute("aria-hidden", "true");
                }
            });
        });

        // Modal de atajos
        Utilidades.registrarEventos("btnCerrarAtajos", {
            click: () => {
                const modal = document.getElementById("modalAtajos");
                modal.style.display = "none";
                modal.setAttribute("aria-hidden", "true");
            }
        });

        // Modal de importar SVG
        const inputArchivoSVG = document.getElementById("inputArchivoSVG");
        if (inputArchivoSVG) {
            inputArchivoSVG.addEventListener("change", (e) => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        const svgText = event.target.result;
                        Canvas2D.importarSVG(svgText);
                        document.getElementById("modalImportarSVG").style.display = "none";
                        document.getElementById("modalImportarSVG").setAttribute("aria-hidden", "true");
                        inputArchivoSVG.value = "";
                    };
                    reader.readAsText(file);
                }
            });
        }

        Utilidades.registrarEventos("btnPegarSVG", {
            click: () => {
                const textareaSVG = document.getElementById("textareaSVG");
                if (textareaSVG && textareaSVG.value) {
                    Canvas2D.importarSVG(textareaSVG.value);
                    document.getElementById("modalImportarSVG").style.display = "none";
                    document.getElementById("modalImportarSVG").setAttribute("aria-hidden", "true");
                    textareaSVG.value = "";
                }
            }
        });

        Utilidades.registrarEventos("btnCargarSVG", {
            click: () => {
                const inputArchivoSVG = document.getElementById("inputArchivoSVG");
                if (inputArchivoSVG) {
                    inputArchivoSVG.click();
                }
            }
        });
    },

    abrirModal(modalId) {
        const modal = document.getElementById(modalId);
        if (modal) {
            modal.style.display = "block";
            modal.setAttribute("aria-hidden", "false");
            const focusableElements = modal.querySelectorAll('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])');
            if (focusableElements.length) focusableElements[0].focus();
        }
    },

    cerrarModalesAbiertos() {
        document.querySelectorAll(".modal").forEach(modal => {
            modal.style.display = "none";
            modal.setAttribute("aria-hidden", "true");
        });
    },

    deshacer() {
        if (posicionHistorial > 0) {
            posicionHistorial--;
            Canvas2D.restaurarEstado(posicionHistorial);
            Utilidades.mostrarMensajeTemporalEstado("Acción deshecha");
            this.actualizarEstadoBotonDeshacer();
        }
    },

    rehacer() {
        if (posicionHistorial < historialEstados.length - 1) {
            posicionHistorial++;
            Canvas2D.restaurarEstado(posicionHistorial);
            Utilidades.mostrarMensajeTemporalEstado("Acción rehecha");
            this.actualizarEstadoBotonDeshacer();
        }
    },

    actualizarEstadoBotonDeshacer() {
        const btnDeshacer = document.getElementById("btnDeshacer");
        const btnRehacer = document.getElementById("btnRehacer");
        if (btnDeshacer) {
            btnDeshacer.disabled = posicionHistorial <= 0;
        }
        if (btnRehacer) {
            btnRehacer.disabled = posicionHistorial >= historialEstados.length - 1;
        }
    },

    cancelarOperacionActual() {
        puntoInicial = null;
        dibujando = false;
        if (escena3DInitializada) {
            Escena3D.cancelarDibujo3D();
        }
        if (entradaDimensionesElement) {
            entradaDimensionesElement.style.display = "none";
        }
        dimensionManualActiva = false;
        const btnDimension = document.getElementById("btnDimension");
        if (btnDimension) {
            btnDimension.classList.remove("active");
            btnDimension.setAttribute("aria-pressed", "false");
        }
        if (distanciaVisualElement) distanciaVisualElement.style.display = "none";
        if (anguloVisualElement) anguloVisualElement.style.display = "none";
        if (ortoVisualElement) ortoVisualElement.style.display = "none";
        Canvas2D.dibujar();
    }
};
// =========================================================================
// Inicialización Principal de la Aplicación
// =========================================================================
document.addEventListener("DOMContentLoaded", () => {
    console.log("DOM cargado. Iniciando aplicación CAD...");
    try {
        if (!Utilidades) {
            throw new Error("Módulo Utilidades no está definido.");
        }
        if (!Canvas2D.inicializar()) {
            throw new Error("Fallo al inicializar Canvas 2D");
        }
        Controles.inicializar();
        Dibujo.actualizarSnapPuntos();
        Utilidades.mostrarMensajeTemporalEstado("Editor CAD listo.", 1500);
        canvas.focus();
    } catch (error) {
        console.error("Error crítico durante la inicialización:", error);
        Utilidades.mostrarMensajeTemporalEstado(`Error al inicializar: ${error.message}`, 5000);
    }
});

// Manejador global de errores no capturados
window.addEventListener("error", (event) => {
    console.error("Error no capturado:", event.error);
    Utilidades.mostrarMensajeTemporalEstado(`Error inesperado: ${event.error?.message || "Desconocido"}`, 5000);
});

// Manejador de promesas rechazadas no capturadas
window.addEventListener("unhandledrejection", (event) => {
    console.error("Promesa rechazada no capturada:", event.reason);
    Utilidades.mostrarMensajeTemporalEstado(`Error asíncrono: ${event.reason?.message || "Desconocido"}`, 5000);
});

    </script>
</body>
</html>
